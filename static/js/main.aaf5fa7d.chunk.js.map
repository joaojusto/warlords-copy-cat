{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["cursors","player","config","scene","create","map","this","make","tilemap","key","tileset","addTilesetImage","worldLayer","createStaticLayer","aboveLayer","setCollisionByProperty","collides","setDepth","spawnPoint","findObject","obj","name","physics","add","sprite","x","y","setSize","setOffset","collider","anims","frames","generateFrameNames","prefix","start","end","zeroPad","frameRate","repeat","camera","cameras","main","startFollow","setBounds","widthInPixels","heightInPixels","input","keyboard","createCursorKeys","update","time","delta","prevVelocity","body","velocity","clone","setVelocity","left","isDown","setVelocityX","right","up","setVelocityY","down","normalize","scale","play","stop","setTexture","preload","load","setBaseURL","process","image","tilemapTiledJSON","atlas","plugins","global","plugin","MoveToPlugin","default","arcade","gravity","type","Phaser","AUTO","width","height","parent","pixelArt","Game","App","className","id","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.aaf5fa7d.chunk.js","sourcesContent":["import React from \"react\";\nimport Phaser from \"phaser\";\nimport MoveToPlugin from \"phaser3-rex-plugins/plugins/moveto-plugin.js\";\n\nconst plugins = {\n  global: [\n    {\n      key: \"rexMoveTo\",\n      plugin: MoveToPlugin,\n      start: true\n    }\n  ]\n};\n\nconst physics = {\n  default: \"arcade\",\n  arcade: {\n    gravity: { y: 0 }\n  }\n};\n\nconst scene = {\n  create,\n  update,\n  preload\n};\n\nconst config = {\n  scene,\n  plugins,\n  physics,\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  parent: \"App\",\n  pixelArt: true\n};\n\n// const warrior = this.plugins.get(\"rexMoveTo\").add(warriorObj, {\n//   // speed: 1000,\n//   // rotateToTarget: true\n// });\n\n// this.input.on(\"pointerdown\", function(pointer) {\n//   const { x, y } = pointer;\n//   // warrior.moveTo(x, y);\n// });\n\nlet cursors;\nlet player;\n\nfunction preload() {\n  this.load.setBaseURL(`${process.env.PUBLIC_URL}`);\n  this.load.image(\"tiles\", `/tilesets/tuxmon-sample-32px-extruded.png`);\n  this.load.tilemapTiledJSON(\"map\", `/tilemaps/tuxemon-town.json`);\n  this.load.atlas(\"atlas\", \"/atlas/atlas.png\", \"/atlas/atlas.json\");\n}\n\nfunction create() {\n  const map = this.make.tilemap({ key: \"map\" });\n\n  // Parameters are the name you gave the tileset in Tiled and then the key of the tileset image in\n  // Phaser's cache (i.e. the name you used in preload)\n  const tileset = map.addTilesetImage(\"tuxmon-sample-32px-extruded\", \"tiles\");\n\n  // Parameters: layer name (or index) from Tiled, tileset, x, y\n  const belowLayer = map.createStaticLayer(\"Below Player\", tileset, 0, 0);\n  const worldLayer = map.createStaticLayer(\"World\", tileset, 0, 0);\n  const aboveLayer = map.createStaticLayer(\"Above Player\", tileset, 0, 0);\n\n  worldLayer.setCollisionByProperty({ collides: true });\n\n  // By default, everything gets depth sorted on the screen in the order we created things. Here, we\n  // want the \"Above Player\" layer to sit on top of the player, so we explicitly give it a depth.\n  // Higher depths will sit on top of lower depth objects.\n  aboveLayer.setDepth(10);\n\n  // Object layers in Tiled let you embed extra info into a map - like a spawn point or custom\n  // collision shapes. In the tmx file, there's an object layer with a point named \"Spawn Point\"\n  const spawnPoint = map.findObject(\n    \"Objects\",\n    obj => obj.name === \"Spawn Point\"\n  );\n\n  // Create a sprite with physics enabled via the physics system. The image used for the sprite has\n  // a bit of whitespace, so I'm using setSize & setOffset to control the size of the player's body.\n  player = this.physics.add\n    .sprite(spawnPoint.x, spawnPoint.y, \"atlas\", \"misa-front\")\n    .setSize(30, 40)\n    .setOffset(0, 24);\n\n  // Watch the player and worldLayer for collisions, for the duration of the scene:\n  this.physics.add.collider(player, worldLayer);\n\n  // Create the player's walking animations from the texture atlas. These are stored in the global\n  // animation manager so any sprite can access them.\n  const anims = this.anims;\n  anims.create({\n    key: \"misa-left-walk\",\n    frames: anims.generateFrameNames(\"atlas\", {\n      prefix: \"misa-left-walk.\",\n      start: 0,\n      end: 3,\n      zeroPad: 3\n    }),\n    frameRate: 10,\n    repeat: -1\n  });\n  anims.create({\n    key: \"misa-right-walk\",\n    frames: anims.generateFrameNames(\"atlas\", {\n      prefix: \"misa-right-walk.\",\n      start: 0,\n      end: 3,\n      zeroPad: 3\n    }),\n    frameRate: 10,\n    repeat: -1\n  });\n  anims.create({\n    key: \"misa-front-walk\",\n    frames: anims.generateFrameNames(\"atlas\", {\n      prefix: \"misa-front-walk.\",\n      start: 0,\n      end: 3,\n      zeroPad: 3\n    }),\n    frameRate: 10,\n    repeat: -1\n  });\n  anims.create({\n    key: \"misa-back-walk\",\n    frames: anims.generateFrameNames(\"atlas\", {\n      prefix: \"misa-back-walk.\",\n      start: 0,\n      end: 3,\n      zeroPad: 3\n    }),\n    frameRate: 10,\n    repeat: -1\n  });\n\n  const camera = this.cameras.main;\n  camera.startFollow(player);\n  camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);\n\n  cursors = this.input.keyboard.createCursorKeys();\n}\n\nfunction update(time, delta) {\n  const speed = 175;\n  const prevVelocity = player.body.velocity.clone();\n\n  // Stop any previous movement from the last frame\n  player.body.setVelocity(0);\n\n  // Horizontal movement\n  if (cursors.left.isDown) {\n    player.body.setVelocityX(-speed);\n  } else if (cursors.right.isDown) {\n    player.body.setVelocityX(speed);\n  }\n\n  // Vertical movement\n  if (cursors.up.isDown) {\n    player.body.setVelocityY(-speed);\n  } else if (cursors.down.isDown) {\n    player.body.setVelocityY(speed);\n  }\n\n  // Normalize and scale the velocity so that player can't move faster along a diagonal\n  player.body.velocity.normalize().scale(speed);\n\n  // Update the animation last and give left/right animations precedence over up/down animations\n  if (cursors.left.isDown) {\n    player.anims.play(\"misa-left-walk\", true);\n  } else if (cursors.right.isDown) {\n    player.anims.play(\"misa-right-walk\", true);\n  } else if (cursors.up.isDown) {\n    player.anims.play(\"misa-back-walk\", true);\n  } else if (cursors.down.isDown) {\n    player.anims.play(\"misa-front-walk\", true);\n  } else {\n    player.anims.stop();\n\n    // If we were moving, pick and idle frame to use\n    if (prevVelocity.x < 0) player.setTexture(\"atlas\", \"misa-left\");\n    else if (prevVelocity.x > 0) player.setTexture(\"atlas\", \"misa-right\");\n    else if (prevVelocity.y < 0) player.setTexture(\"atlas\", \"misa-back\");\n    else if (prevVelocity.y > 0) player.setTexture(\"atlas\", \"misa-front\");\n  }\n}\n\nnew Phaser.Game(config);\n\nfunction App() {\n  return <div className=\"App\" id=\"App\"></div>;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}