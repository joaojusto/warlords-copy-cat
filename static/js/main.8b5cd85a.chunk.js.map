{"version":3,"sources":["MiniMap.js","UI.js","TerrainGen.js","Scene.js","Movement.js","Army.js","Player.js","GameScene.js","Map.js","Game.js","App.js","index.js"],"names":["CONFIG","UI","Scene","call","key","active","game","this","scene","get","mapWidth","mapHeight","width","height","margin","name","background","zoom","center","x","y","positon","cameras","add","setZoom","setName","centerOn","setBackgroundColor","MiniMap","terrainLayer","player","players","title","text","turn","fill","setInteractive","on","target","movement","clear","endTurn","setText","setClickCursor","setDefaultCursor","TERRAIN_ID","FOREST_ID","SAND_ID","CASTLE_ID","MOUNTAIN_ID","WATER_ID","Input","Keyboard","KeyCodes","Q","E","SmoothedKeyControl","Cameras","Controls","input","keyboard","createCursorKeys","left","right","config","up","down","camera","zoomIn","addKey","zoomOut","drag","maxSpeed","acceleration","controls","setBounds","setScroll","mapControls","main","pathFinder","finder","entityMover","minimapCamera","minimap","terrain","PhaserScene","INITIAL_STATE","path","cost","totalCost","currentTurn","nextTurns","indicators","nextIndicators","costMatrix","tileWidth","tileHeight","graphics","state","worldX","value","worldY","destroy","createPathPoint","circle","Geom","Circle","fillCircleShape","onComplete","stopFollow","body","move","length","isEqual","tweens","map","targets","duration","startFollow","timeline","spendMovement","doMove","nextState","slice","reduce","tileCost","movementPoints","pathReducer","fillStyle","Army","type","amount","resetMovement","update","embedded","touching","none","wasTouching","emit","physics","sprite","setDisplaySize","setDisplayOrigin","onCastle","debugBodyColor","alert","triggers","forEach","trigger","overlap","money","armies","castles","id","army","addArmy","newArmy","worldToTile","Math","floor","cursor","process","GameScene","onPointerDown","pointer","rightButtonDown","to","from","onPathCalculated","findPath","calculate","error","console","playerId","newPlayer","Player","push","load","setBaseURL","image","mouse","disableContextMenu","world","spawnPoint","make","tilemap","tileset","addTilesetImage","createBlankDynamicLayer","objectLayer","EasyStar","js","setGrid","setAcceptableTiles","enableDiagonals","setCost","tile","setTileCost","row","includes","putTileAt","zone","setSize","enable","setAllowGravity","moves","setOpenCursor","convertLayerToStatic","setTileIndexCallback","log","Map","seed","random","noise","Noise","min","max","bellow0","above0","matrix","range","perlin2","waterLevel","sandLevel","isSand","level","isWater","isTerrain","sandTile","sample","topLeft","progress","top","topRight","bottomLeft","bottom","bottomRight","tileType","tileTypeFactory","normalized","fitsCastle","possiblePositions","flatMap","filter","distance","a","b","abs","placeCastle","outsideRadious","points","point","radious","every","existingPoint","findCastlePosition","index","outside","placeCastles","r","generator","spawn","addPlayer","setupCamera","Movement","createMapControls","run","time","delta","PhaserMath","Clamp","selectedTarget","default","arcade","debug","gravity","Phaser","AUTO","parent","pixelArt","Game","App","className","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.8b5cd85a.chunk.js","sourcesContent":["const CONFIG = {\n  width: 102,\n  height: 102,\n  margin: 10,\n  padding: 2,\n  background: 0x002244,\n  name: \"minimap\"\n};\n\nexport default (scene, mapWidth, mapHeight) => {\n  const { width, height, margin, padding, name, background } = CONFIG;\n\n  const zoom = (height - padding) / mapHeight;\n  const center = { x: mapWidth / 2, y: mapHeight / 2 };\n  const positon = { x: scene.width - width - margin, y: margin };\n\n  return scene.cameras\n    .add(positon.x, positon.y, width, height)\n    .setZoom(zoom)\n    .setName(name)\n    .centerOn(center.x, center.y)\n    .setBackgroundColor(background);\n};\n","import { Scene } from \"phaser\";\n\nimport MiniMap from \"./MiniMap\";\n\nexport default class UI extends Scene {\n  constructor() {\n    super(\"UIScene\");\n    Scene.call(this, { key: \"UI\", active: false });\n  }\n\n  create() {\n    const game = this.scene.get(\"GameScene\");\n    MiniMap(game, game.terrainLayer.width, game.terrainLayer.height);\n\n    const player = game.players[0];\n\n    const title = this.add.text(\n      20,\n      20,\n      `Current Player: ${player.name()}, turn: ${player.turn()}`,\n      { fill: \"#000000\" }\n    );\n\n    const button = this.add\n      .text(700, 560, `End Turn`, { fill: \"#000000\" })\n      .setInteractive()\n      .on(\"pointerdown\", () => {\n        game.target = null;\n        game.movement.clear();\n        player.endTurn();\n        title.setText(\n          `Current Player: ${player.name()}, turn: ${player.turn()}`\n        );\n      })\n      .on(\"pointerover\", () => game.setClickCursor())\n      .on(\"pointerout\", () => game.setDefaultCursor());\n  }\n}\n","import { Noise } from \"noisejs\";\nimport {\n  findLast,\n  range,\n  sample,\n  sortBy,\n  includes,\n  every,\n  filter\n} from \"lodash\";\nimport { progress } from \"@popmotion/popcorn\";\n\nexport const TERRAIN_ID = [2];\nexport const FOREST_ID = [4, 5, 6];\nexport const SAND_ID = [8, 9, 10, 11, 12, 13, 14, 15];\nexport const CASTLE_ID = [16, 17, 24, 25];\nexport const MOUNTAIN_ID = [1];\nexport const WATER_ID = [3, 7];\n\nconst ZOOM_FACTOR = 12;\n\nexport default (width, height, seed = Math.random()) => {\n  const noise = new Noise();\n  noise.seed(seed);\n  const zoom = (width * ZOOM_FACTOR) / 100;\n\n  let min = 0;\n  let max = 0;\n  let bellow0 = 0;\n  let above0 = 0;\n\n  const matrix = range(height).map(y => {\n    return range(width).map(x => {\n      const value = noise.perlin2(x / zoom, y / zoom);\n\n      min = value < min ? value : min;\n      max = value > max ? value : max;\n\n      if (value < 0) bellow0++;\n      else above0++;\n\n      return value;\n    });\n  });\n\n  // let islands = [];\n\n  // const border = 0.2;\n  const waterLevel = 0.45;\n  const sandLevel = waterLevel + 0.1;\n\n  // const isAdjacent = (x, y) => island =>\n  //   (x + 1 === island.x || x - 1 === island.x || x === island.x) &&\n  //   (y + 1 === island.y || y - 1 === island.y || y === island.y);\n\n  const isSand = level => level >= waterLevel && level < sandLevel;\n  const isWater = level => level < waterLevel;\n  const isTerrain = level => !isSand(level) && !isWater(level);\n\n  const sandTile = (matrix, x, y) => {\n    if (y - 1 < 0 || y + 1 >= matrix.length) return sample(WATER_ID);\n    if (x - 1 < 0 || x + 1 >= matrix.length) return sample(WATER_ID);\n\n    const topLeft = progress(min, max, matrix[y - 1][x - 1]);\n    const top = progress(min, max, matrix[y - 1][x]);\n    const topRight = progress(min, max, matrix[y - 1][x + 1]);\n    const left = progress(min, max, matrix[y][x - 1]);\n    const right = progress(min, max, matrix[y][x + 1]);\n    const bottomLeft = progress(min, max, matrix[y + 1][x - 1]);\n    const bottom = progress(min, max, matrix[y + 1][x]);\n    const bottomRight = progress(min, max, matrix[y + 1][x + 1]);\n\n    if (\n      !isTerrain(top) &&\n      !isTerrain(left) &&\n      !isTerrain(right) &&\n      !isTerrain(bottom)\n    )\n      return sample(WATER_ID);\n\n    if (isTerrain(bottom) && isTerrain(right)) return SAND_ID[7];\n    if (isTerrain(top) && isTerrain(right)) return SAND_ID[2];\n    if (isTerrain(bottom) && isTerrain(left)) return SAND_ID[5];\n    if (isTerrain(top) && isTerrain(left)) return SAND_ID[0];\n\n    if (isTerrain(top)) return SAND_ID[1];\n    if (isTerrain(bottom)) return SAND_ID[6];\n    if (isTerrain(right)) return SAND_ID[3];\n    if (isTerrain(left)) return SAND_ID[4];\n\n    if (topLeft < waterLevel && top < waterLevel && topRight < waterLevel) {\n      return SAND_ID[6];\n    }\n\n    if (\n      bottomLeft < waterLevel &&\n      bottom < waterLevel &&\n      bottomRight < waterLevel\n    ) {\n      return SAND_ID[1];\n    }\n  };\n\n  const tileType = matrix => (tile, x, y) => {\n    const value = progress(min, max, tile);\n    if (isWater(value)) return sample(WATER_ID);\n    if (isSand(value)) return sandTile(matrix, x, y);\n    // if (value >= 0.6 && value < 0.61) return sample(CASTLE_ID);\n    if (value >= 0.7 && value < 0.8) return sample(FOREST_ID);\n    if (value >= 0.8) return sample(MOUNTAIN_ID);\n    return sample(TERRAIN_ID);\n  };\n\n  const tileTypeFactory = tileType(matrix);\n\n  const normalized = matrix.map((row, y) =>\n    row.map((tile, x) => {\n      // if (y < height * border || y > height * (1 - border)) return WATER_ID;\n      // if (x < width * border || x > width * (1 - border)) return WATER_ID;\n\n      // const value = progress(min, max, tile);\n      // if (value < waterLevel) return WATER_ID;\n\n      return tileTypeFactory(tile, x, y);\n      // const adjcentTiles = findLast(islands, island =>\n      //   findLast(island, isAdjacent(x, y))\n      // );\n      //\n      // if (adjcentTiles) {\n      //   adjcentTiles.push({ x, y, type: tileType(tile) });\n      // } else {\n      //   islands.push([{ x, y, type: tileType(tile) }]);\n      // }\n\n      // return WATER_ID;\n    })\n  );\n\n  const randomTile = () => {\n    const x = Math.floor(Math.random() * width);\n    const y = Math.floor(Math.random() * height);\n    return { x, y };\n  };\n\n  const fitsCastle = ({ x, y }) => {\n    if (y - 1 < 0 || x - 1 < 0) return false;\n\n    const topLeft = normalized[y - 1][x - 1];\n    const topRight = normalized[y - 1][x];\n    const left = normalized[y][x - 1];\n    const right = normalized[y][x];\n\n    const isTerrain = value => includes(TERRAIN_ID, value);\n\n    return (\n      isTerrain(topLeft) &&\n      isTerrain(topRight) &&\n      isTerrain(left) &&\n      isTerrain(right)\n    );\n  };\n\n  const possiblePositions = normalized\n    .flatMap((row, y) => row.map((tile, x) => ({ x, y })))\n    .filter(fitsCastle);\n\n  const distance = (a, b) => Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n\n  const placeCastle = ({ x, y }) => {\n    normalized[y - 1][x - 1] = CASTLE_ID[0];\n    normalized[y - 1][x] = CASTLE_ID[1];\n    normalized[y][x - 1] = CASTLE_ID[2];\n    normalized[y][x] = CASTLE_ID[3];\n\n    return { x, y };\n  };\n\n  const outsideRadious = (points, point, radious) =>\n    every(points, existingPoint => distance(existingPoint, point) > radious);\n\n  const findCastlePosition = radious => (points, index) => {\n    let point = sample(possiblePositions);\n    let outside = outsideRadious(points, point, radious);\n\n    while (!outside) {\n      point = sample(possiblePositions);\n      outside = outsideRadious(points, point, radious);\n    }\n\n    return [...points, point];\n  };\n\n  const placeCastles = () => {\n    const amount = 20;\n    const exclusionRadious = 20;\n    const r = range(amount)\n      .reduce(findCastlePosition(exclusionRadious), [])\n      .map(placeCastle);\n\n    console.log(r.length);\n    console.log(r);\n\n    return r;\n  };\n\n  placeCastles();\n\n  console.log(`Min: ${min}, Max: ${max}`);\n  console.log(`<0: ${bellow0}, >0: ${above0}`);\n  console.log(`Seed: ${seed}`);\n\n  // console.log(islands.length, islands);\n  // sortBy(islands, \"length\")\n  //   .reverse()[0]\n  //   .forEach(({ x, y, type }) => (normalized[y][x] = type));\n  return normalized;\n};\n\nexport const toEmoji = map =>\n  map.map(row => row.map(column => (column === 0 ? \"🌊\" : \"🌲\")));\n\nexport const toConsole = map =>\n  map.forEach((row, index) => {\n    console.log(`${index}: ${row.join(\"\")}`);\n  });\n","import { Scene as PhaserScene, Cameras, Input } from \"phaser\";\n\nexport default class Scene extends PhaserScene {\n  get controls() {\n    return this.mapControls;\n  }\n\n  set controls(controls) {\n    this.mapControls = controls;\n  }\n\n  get camera() {\n    return this.cameras.main;\n  }\n\n  get keyboard() {\n    return this.input.keyboard;\n  }\n\n  get width() {\n    return this.game.config.width;\n  }\n\n  get height() {\n    return this.game.config.height;\n  }\n\n  get finder() {\n    return this.pathFinder;\n  }\n\n  set finder(finder) {\n    this.pathFinder = finder;\n  }\n\n  get movement() {\n    return this.entityMover;\n  }\n\n  set movement(movement) {\n    this.entityMover = movement;\n  }\n\n  get minimap() {\n    return this.minimapCamera;\n  }\n\n  set minimap(minimap) {\n    this.minimapCamera = minimap;\n  }\n\n  get terrainLayer() {\n    return this.terrain;\n  }\n\n  set terrainLayer(terrainLayer) {\n    this.terrain = terrainLayer;\n  }\n\n  createMapControls() {\n    const { Q, E } = Input.Keyboard.KeyCodes;\n    const { SmoothedKeyControl } = Cameras.Controls;\n    const { left, right, up, down } = this.input.keyboard.createCursorKeys();\n\n    const config = {\n      up: up,\n      down: down,\n      left: left,\n      right: right,\n      camera: this.camera,\n      zoomIn: this.keyboard.addKey(Q),\n      zoomOut: this.keyboard.addKey(E),\n      drag: 0.6,\n      maxSpeed: 200.0,\n      acceleration: 2.8\n    };\n\n    this.controls = new SmoothedKeyControl(config);\n  }\n\n  setupCamera(mapWidth, mapHeight) {\n    const { width, height } = this.camera;\n\n    this.camera.setBounds(0, 0, mapWidth, mapHeight);\n    this.camera.setScroll(\n      -(width / 2) + mapWidth / 2,\n      -(height / 2) + mapHeight / 2\n    );\n  }\n}\n","import { isEqual } from \"lodash\";\nimport { Geom } from \"phaser\";\n\nconst INITIAL_STATE = {\n  path: [],\n  cost: 0,\n  totalCost: 0,\n  currentTurn: [],\n  nextTurns: [],\n  indicators: [],\n  nextIndicators: []\n};\n\nconst pathReducer = (costMatrix, target) => (state, { x, y }) => {\n  const { cost, totalCost, currentTurn, nextTurns } = state;\n  const tileCost = costMatrix[y][x];\n\n  if (totalCost + tileCost <= target.movementPoints)\n    return {\n      ...state,\n      cost: cost + tileCost,\n      totalCost: totalCost + tileCost,\n      currentTurn: [...currentTurn, { x, y }]\n    };\n\n  return { ...state, nextTurns: [...nextTurns, { x, y }] };\n};\n\nexport default (scene, costMatrix, tileWidth, tileHeight) => {\n  let graphics = scene.add.graphics();\n  let state = INITIAL_STATE;\n\n  const worldX = value => value * tileWidth;\n  const worldY = value => value * tileHeight;\n\n  const clear = () => {\n    graphics.destroy();\n    graphics = scene.add.graphics();\n    state = INITIAL_STATE;\n  };\n\n  const createPathPoint = ({ x, y }) => {\n    const positon = {\n      x: worldX(x) + tileWidth / 2,\n      y: worldY(y) + tileHeight / 2\n    };\n    const circle = new Geom.Circle(positon.x, positon.y, 8);\n    graphics.fillCircleShape(circle);\n    return circle;\n  };\n\n  const onComplete = target => () => {\n    scene.camera.stopFollow(target.body);\n    clear();\n  };\n\n  const doMove = target => {\n    const { cost, currentTurn } = state;\n    const tweens = currentTurn.map(({ x, y }) => ({\n      targets: target.body,\n      x: { value: worldX(x), duration: 200 },\n      y: { value: worldY(y), duration: 200 }\n    }));\n\n    scene.camera.startFollow(target.body);\n    scene.tweens.timeline({ tweens, onComplete: onComplete(target) });\n\n    target.spendMovement(cost);\n  };\n\n  const move = target => path => {\n    if (!path || path.length <= 1) return clear();\n\n    if (state && state.currentTurn.length && isEqual(state.path, path))\n      return doMove(target);\n\n    clear();\n\n    const nextState = path\n      .slice(1, path.length)\n      .reduce(pathReducer(costMatrix, target), { ...INITIAL_STATE, path });\n\n    let { currentTurn, nextTurns } = nextState;\n\n    graphics.fillStyle(0xffffff, 1); // color: white\n    nextState.indicators = currentTurn.map(createPathPoint);\n\n    graphics.fillStyle(0xff0000, 1); // color: red\n    nextState.nextIndicators = nextTurns.map(createPathPoint);\n\n    state = nextState;\n  };\n\n  return { move, clear };\n};\n","export default class Army {\n  constructor(scene, x, y, type) {\n    this.scene = scene;\n    this.movementPoints = 4;\n    this.body = scene.physics.add\n      .sprite(x, y, type)\n      .setDisplaySize(64, 64)\n      .setDisplayOrigin(-16, -10)\n      .setInteractive()\n      .on(\"pointerdown\", () => (scene.target = this));\n\n    this.onCastle = false;\n\n    this.body.on(\"overlapstart\", function() {\n      this.body.debugBodyColor = 0xff3300;\n      this.onCastle = true;\n      alert(\"You're on a castle\");\n    });\n\n    this.body.on(\"overlapend\", function() {\n      this.body.debugBodyColor = 0x00ff33;\n      this.onCastle = false;\n    });\n\n    this.scene.triggers.forEach(trigger => {\n      this.scene.physics.add.overlap(this.body, trigger);\n    });\n  }\n\n  spendMovement = amount => (this.movementPoints -= amount);\n\n  resetMovement = () => (this.movementPoints = 4);\n\n  update = () => {\n    const {\n      body: { body }\n    } = this;\n\n    if (body.embedded) body.touching.none = false;\n\n    const touching = !body.touching.none;\n    const wasTouching = !body.wasTouching.none;\n\n    if (touching && !wasTouching) this.body.emit(\"overlapstart\");\n    else if (!touching && wasTouching) this.body.emit(\"overlapend\");\n  };\n}\n","import Army from \"./Army\";\n\nconst INITIAL_STATE = {\n  turn: 1,\n  name: \"\",\n  money: 0,\n  armies: [],\n  castles: []\n};\n\nconst player = (scene, id) => {\n  let state = {\n    ...INITIAL_STATE,\n    name: `Player ${id}`\n  };\n\n  const endTurn = () => {\n    state.armies.forEach(army => army.resetMovement());\n\n    state = {\n      ...state,\n      turn: state.turn + 1\n    };\n  };\n\n  const addArmy = (x, y, type) => {\n    const newArmy = new Army(scene, x, y, type);\n    state = {\n      ...state,\n      armies: [...state.armies, newArmy]\n    };\n    return newArmy;\n  };\n\n  const name = () => state.name;\n  const turn = () => state.turn;\n  const update = () => state.armies.forEach(army => army.update());\n\n  return {\n    state,\n    name,\n    turn,\n    update,\n    endTurn,\n    addArmy\n  };\n};\n\nexport default player;\n","import { Math as PhaserMath, Scene as PhaserScene } from \"phaser\";\n\nimport generator from \"./TerrainGen\";\nimport Scene from \"./Scene\";\nimport Map from \"./Map\";\nimport Movement from \"./Movement\";\nimport Player from \"./Player\";\n\nconst MAP_WIDTH = 100;\nconst MAP_HEIGHT = 100;\nconst TILE_WIDTH = 128;\nconst TILE_HEIGHT = 128;\n// const SEED = 0.8444330836642344;\n\nconst worldToTile = (x, y) => ({\n  x: Math.floor(x / TILE_WIDTH),\n  y: Math.floor(y / TILE_HEIGHT)\n});\n\nconst tileToWorld = (x, y) => ({\n  x: Math.floor(x * TILE_WIDTH),\n  y: Math.floor(y * TILE_HEIGHT)\n});\n\nconst cursor = name => {\n  return `url(${process.env.PUBLIC_URL}/${name}.png), pointer`;\n};\n\nexport default class GameScene extends Scene {\n  constructor() {\n    super(\"GameScene\");\n    this.players = [];\n  }\n\n  get target() {\n    return this.selectedTarget;\n  }\n\n  set target(selectedTarget) {\n    this.selectedTarget = selectedTarget;\n\n    if (selectedTarget) this.input.setDefaultCursor(cursor(\"cursor_move\"));\n    else this.input.setDefaultCursor(cursor(\"cursor\"));\n  }\n\n  setClickCursor() {\n    this.input.setDefaultCursor(cursor(\"cursor\"));\n  }\n\n  setOpenCursor() {\n    this.input.setDefaultCursor(cursor(\"cursor_open\"));\n  }\n\n  setDefaultCursor() {\n    if (this.target) this.input.setDefaultCursor(cursor(\"cursor_move\"));\n    else this.input.setDefaultCursor(cursor(\"cursor\"));\n  }\n\n  addPlayer() {\n    const playerId = this.players.length;\n    const newPlayer = Player(this, playerId);\n    this.players.push(newPlayer);\n    return newPlayer;\n  }\n\n  preload() {\n    this.load.setBaseURL(`${process.env.PUBLIC_URL}`);\n    this.load.image(\"tileset\", \"tilesets/tileset-extruded.png\");\n    this.load.image(\"warrior\", \"warrior.png\");\n    // this.load.tilemapTiledJSON(\"map\", \"/tilemaps/copycat.json\");\n  }\n\n  create() {\n    this.input.setDefaultCursor(cursor(\"cursor\"));\n    this.input.mouse.disableContextMenu();\n\n    const world = generator(MAP_WIDTH, MAP_HEIGHT);\n    const { map, finder, costMatrix, spawnPoint, terrainLayer } = Map(\n      this,\n      world,\n      MAP_WIDTH,\n      MAP_HEIGHT\n    );\n    this.finder = finder;\n    this.terrainLayer = terrainLayer;\n    const { tileWidth, tileHeight } = map;\n\n    const spawn = tileToWorld(spawnPoint.x - 2, spawnPoint.y + 2);\n\n    const player = this.addPlayer();\n    this.target = player.addArmy(spawn.x, spawn.y, \"warrior\");\n\n    this.setupCamera(terrainLayer.width, terrainLayer.height);\n    this.camera.centerOn(spawn.x, spawn.y);\n\n    this.movement = Movement(this, costMatrix, tileWidth, tileHeight);\n\n    this.createMapControls();\n    this.input.on(\"pointerdown\", this.onPointerDown);\n\n    this.scene.run(\"UI\");\n  }\n\n  onPointerDown = pointer => {\n    if (pointer.rightButtonDown()) {\n      this.target = null;\n    }\n    if (!this.target) return;\n\n    const { worldX, worldY } = pointer;\n    const to = worldToTile(worldX, worldY);\n    const from = worldToTile(this.target.body.x, this.target.body.y);\n    const onPathCalculated = this.movement.move(this.target);\n\n    try {\n      this.finder.findPath(from.x, from.y, to.x, to.y, onPathCalculated);\n      this.finder.calculate();\n    } catch (error) {\n      console.error(\"Ups! Out of scope :S\");\n    }\n  };\n\n  update(time, delta) {\n    this.controls.update(delta);\n    this.camera.setZoom(PhaserMath.Clamp(this.camera.zoom, 0.08, 1));\n    this.players.forEach(player => player.update());\n  }\n}\n","import EasyStar from \"easystarjs\";\nimport { includes } from \"lodash\";\n\nimport {\n  TERRAIN_ID,\n  FOREST_ID,\n  CASTLE_ID,\n  MOUNTAIN_ID,\n  WATER_ID\n} from \"./TerrainGen\";\n\nconst setTileCost = (costMatrix, finder) => (tile, x, y, cost) => {\n  finder.setTileCost(tile, cost);\n  costMatrix[y] = costMatrix[y] || [];\n  costMatrix[y][x] = cost;\n};\n\nexport default (scene, world, width, height) => {\n  const map = scene.make.tilemap({ tileWidth: 128, tileHeight: 128 });\n  const { tileWidth, tileHeight } = map;\n  const tileset = map.addTilesetImage(\n    \"tileset\",\n    \"tileset\",\n    tileWidth,\n    tileHeight,\n    1,\n    2\n  );\n\n  let terrainLayer = map.createBlankDynamicLayer(\n    \"terrain\",\n    tileset,\n    0,\n    0,\n    width,\n    height\n  );\n\n  let objectLayer = map.createBlankDynamicLayer(\n    \"object\",\n    tileset,\n    0,\n    0,\n    width,\n    height\n  );\n\n  let spawnPoint;\n\n  const finder = new EasyStar.js();\n  finder.setGrid(world);\n  finder.setAcceptableTiles([...TERRAIN_ID, ...MOUNTAIN_ID, ...FOREST_ID]);\n  finder.enableDiagonals();\n  // finder.enableCornerCutting();\n\n  const costMatrix = [];\n  const setCost = setTileCost(costMatrix, finder);\n  scene.triggers = [];\n\n  world.forEach((row, y) =>\n    row.forEach((tile, x) => {\n      if (!spawnPoint && includes(CASTLE_ID, tile)) spawnPoint = { x, y };\n\n      if (includes(CASTLE_ID, tile)) {\n        terrainLayer.putTileAt(TERRAIN_ID[0], x, y);\n        objectLayer.putTileAt(tile, x, y);\n        if (tile === CASTLE_ID[0]) {\n          const trigger = scene.add\n            .zone(x * tileWidth + tileWidth, y * tileWidth + tileHeight)\n            .setSize(tileWidth * 2 + 64, tileHeight * 2 + 64);\n          scene.physics.world.enable(trigger);\n          trigger.body.setAllowGravity(false);\n          trigger.body.moves = false;\n          trigger.setInteractive();\n          scene.triggers.push(trigger);\n          trigger.on(\"pointerover\", () => scene.setOpenCursor());\n          trigger.on(\"pointerout\", () => scene.setDefaultCursor());\n        }\n      } else terrainLayer.putTileAt(tile, x, y);\n\n      if (includes(TERRAIN_ID, tile)) setCost(tile, x, y, 1);\n      if (includes(FOREST_ID, tile)) setCost(tile, x, y, 2);\n      if (includes(MOUNTAIN_ID, tile)) setCost(tile, x, y, 3);\n    })\n  );\n\n  terrainLayer = map.convertLayerToStatic(terrainLayer);\n  objectLayer = map.convertLayerToStatic(objectLayer);\n\n  objectLayer.setTileIndexCallback(24, () => console.log(\"here 24\"), scene);\n  objectLayer.setTileIndexCallback(25, () => console.log(\"here 25\"), scene);\n\n  scene.objectLayer = objectLayer;\n\n  return {\n    map,\n    finder,\n    costMatrix,\n    spawnPoint,\n    terrainLayer\n  };\n};\n","import Phaser, { Game } from \"phaser\";\n\n// import game from \"./Game\";\nimport UI from \"./UI\";\nimport GameScene from \"./GameScene\";\n\nconst physics = {\n  default: \"arcade\",\n  arcade: {\n    debug: true,\n    gravity: { y: 0 }\n  }\n};\n\nconst config = {\n  physics,\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  parent: \"App\",\n  pixelArt: true,\n  scene: [GameScene, UI]\n};\n\nnew Game(config);\n","import React from \"react\";\n\nimport \"./App.css\";\n\n// import \"./StaticTileMap\";\nimport \"./Game\";\n\nfunction App() {\n  return <div className=\"App\" id=\"App\"></div>;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}