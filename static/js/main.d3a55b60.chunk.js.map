{"version":3,"sources":["MiniMap.js","UI.js","TerrainGen.js","Scene.js","Movement.js","Player.js","GameScene.js","Map.js","Game.js","App.js","index.js"],"names":["CONFIG","UI","Scene","call","key","active","game","this","scene","get","mapWidth","mapHeight","width","height","margin","name","background","zoom","center","x","y","positon","cameras","add","setZoom","setName","centerOn","setBackgroundColor","MiniMap","terrainLayer","player","players","title","text","turn","fill","setInteractive","on","target","movement","clear","endTurn","setText","TERRAIN_ID","FOREST_ID","SAND_ID","MOUNTAIN_ID","WATER_ID","Input","Keyboard","KeyCodes","Q","E","SmoothedKeyControl","Cameras","Controls","input","keyboard","createCursorKeys","left","right","config","up","down","camera","zoomIn","addKey","zoomOut","drag","maxSpeed","acceleration","controls","setBounds","setScroll","mapControls","main","pathFinder","finder","entityMover","minimapCamera","minimap","selectedTarget","terrain","PhaserScene","INITIAL_STATE","path","cost","totalCost","currentTurn","nextTurns","indicators","nextIndicators","costMatrix","tileWidth","tileHeight","graphics","state","worldX","value","worldY","destroy","createPathPoint","circle","Geom","Circle","fillCircleShape","onComplete","stopFollow","body","move","length","isEqual","tweens","map","targets","duration","startFollow","timeline","spendMovement","doMove","nextState","slice","reduce","tileCost","movementPoints","pathReducer","fillStyle","money","armies","castles","Army","type","amount","resetMovement","physics","sprite","setDisplaySize","setDisplayOrigin","id","forEach","army","addArmy","newArmy","worldToTile","Math","floor","GameScene","onPointerDown","to","from","onPathCalculated","findPath","calculate","error","console","playerId","newPlayer","Player","push","load","setBaseURL","process","image","world","spawnPoint","make","tilemap","tiles","addTilesetImage","createBlankDynamicLayer","EasyStar","js","setGrid","setAcceptableTiles","enableDiagonals","setCost","tile","setTileCost","row","includes","putTileAt","convertLayerToStatic","Map","seed","random","noise","Noise","min","max","bellow0","above0","matrix","range","perlin2","waterLevel","sandLevel","isSand","level","isWater","isTerrain","sandTile","sample","topLeft","progress","top","topRight","bottomLeft","bottom","bottomRight","tileType","tileTypeFactory","normalized","log","generator","addPlayer","setupCamera","Movement","createMapControls","run","time","delta","update","PhaserMath","Clamp","default","arcade","gravity","Phaser","AUTO","parent","pixelArt","Game","App","className","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.d3a55b60.chunk.js","sourcesContent":["const CONFIG = {\n  width: 102,\n  height: 102,\n  margin: 10,\n  padding: 2,\n  background: 0x002244,\n  name: \"minimap\"\n};\n\nexport default (scene, mapWidth, mapHeight) => {\n  const { width, height, margin, padding, name, background } = CONFIG;\n\n  const zoom = (height - padding) / mapHeight;\n  const center = { x: mapWidth / 2, y: mapHeight / 2 };\n  const positon = { x: scene.width - width - margin, y: margin };\n\n  return scene.cameras\n    .add(positon.x, positon.y, width, height)\n    .setZoom(zoom)\n    .setName(name)\n    .centerOn(center.x, center.y)\n    .setBackgroundColor(background);\n};\n","import { Scene } from \"phaser\";\n\nimport MiniMap from \"./MiniMap\";\n\nexport default class UI extends Scene {\n  constructor() {\n    super(\"UIScene\");\n    Scene.call(this, { key: \"UI\", active: false });\n  }\n\n  create() {\n    const game = this.scene.get(\"GameScene\");\n    MiniMap(game, game.terrainLayer.width, game.terrainLayer.height);\n\n    const player = game.players[0];\n\n    const title = this.add.text(\n      20,\n      20,\n      `Current Player: ${player.name()}, turn: ${player.turn()}`,\n      { fill: \"#000000\" }\n    );\n\n    const button = this.add\n      .text(700, 560, `End Turn`, { fill: \"#000000\" })\n      .setInteractive()\n      .on(\"pointerdown\", () => {\n        game.target = null;\n        game.movement.clear();\n        player.endTurn();\n        title.setText(\n          `Current Player: ${player.name()}, turn: ${player.turn()}`\n        );\n      });\n  }\n}\n","import { Noise } from \"noisejs\";\nimport { findLast, range, sample, sortBy } from \"lodash\";\nimport { progress } from \"@popmotion/popcorn\";\n\nexport const TERRAIN_ID = [2];\nexport const FOREST_ID = [4, 5, 6];\nexport const SAND_ID = [8, 9, 10, 11, 12, 13, 14, 15];\nexport const CASTLE_ID = [];\nexport const MOUNTAIN_ID = [1];\nexport const WATER_ID = [3, 7];\n\nconst ZOOM_FACTOR = 12;\n\nexport default (width, height, seed = Math.random()) => {\n  const noise = new Noise();\n  noise.seed(seed);\n  const zoom = (width * ZOOM_FACTOR) / 100;\n\n  let min = 0;\n  let max = 0;\n  let bellow0 = 0;\n  let above0 = 0;\n\n  const matrix = range(height).map(y => {\n    return range(width).map(x => {\n      const value = noise.perlin2(x / zoom, y / zoom);\n\n      min = value < min ? value : min;\n      max = value > max ? value : max;\n\n      if (value < 0) bellow0++;\n      else above0++;\n\n      return value;\n    });\n  });\n\n  // let islands = [];\n\n  // const border = 0.2;\n  const waterLevel = 0.45;\n  const sandLevel = waterLevel + 0.1;\n\n  // const isAdjacent = (x, y) => island =>\n  //   (x + 1 === island.x || x - 1 === island.x || x === island.x) &&\n  //   (y + 1 === island.y || y - 1 === island.y || y === island.y);\n\n  const isSand = level => level >= waterLevel && level < sandLevel;\n  const isWater = level => level < waterLevel;\n  const isTerrain = level => !isSand(level) && !isWater(level);\n\n  const sandTile = (matrix, x, y) => {\n    if (y - 1 < 0 || y + 1 >= matrix.length) return sample(WATER_ID);\n    if (x - 1 < 0 || x + 1 >= matrix.length) return sample(WATER_ID);\n\n    const topLeft = progress(min, max, matrix[y - 1][x - 1]);\n    const top = progress(min, max, matrix[y - 1][x]);\n    const topRight = progress(min, max, matrix[y - 1][x + 1]);\n    const left = progress(min, max, matrix[y][x - 1]);\n    const right = progress(min, max, matrix[y][x + 1]);\n    const bottomLeft = progress(min, max, matrix[y + 1][x - 1]);\n    const bottom = progress(min, max, matrix[y + 1][x]);\n    const bottomRight = progress(min, max, matrix[y + 1][x + 1]);\n\n    if (\n      !isTerrain(top) &&\n      !isTerrain(left) &&\n      !isTerrain(right) &&\n      !isTerrain(bottom)\n    )\n      return sample(WATER_ID);\n\n    if (isTerrain(bottom) && isTerrain(right)) return SAND_ID[7];\n    if (isTerrain(top) && isTerrain(right)) return SAND_ID[2];\n    if (isTerrain(bottom) && isTerrain(left)) return SAND_ID[5];\n    if (isTerrain(top) && isTerrain(left)) return SAND_ID[0];\n\n    if (isTerrain(top)) return SAND_ID[1];\n    if (isTerrain(bottom)) return SAND_ID[6];\n    if (isTerrain(right)) return SAND_ID[3];\n    if (isTerrain(left)) return SAND_ID[4];\n\n    if (topLeft < waterLevel && top < waterLevel && topRight < waterLevel) {\n      return SAND_ID[6];\n    }\n\n    if (\n      bottomLeft < waterLevel &&\n      bottom < waterLevel &&\n      bottomRight < waterLevel\n    ) {\n      return SAND_ID[1];\n    }\n  };\n\n  const tileType = matrix => (tile, x, y) => {\n    const value = progress(min, max, tile);\n    if (isWater(value)) return sample(WATER_ID);\n    if (isSand(value)) return sandTile(matrix, x, y);\n    // if (value >= 0.6 && value < 0.61) return sample(CASTLE_ID);\n    if (value >= 0.7 && value < 0.8) return sample(FOREST_ID);\n    if (value >= 0.8) return sample(MOUNTAIN_ID);\n    return sample(TERRAIN_ID);\n  };\n\n  const tileTypeFactory = tileType(matrix);\n\n  const normalized = matrix.map((row, y) =>\n    row.map((tile, x) => {\n      // if (y < height * border || y > height * (1 - border)) return WATER_ID;\n      // if (x < width * border || x > width * (1 - border)) return WATER_ID;\n\n      // const value = progress(min, max, tile);\n      // if (value < waterLevel) return WATER_ID;\n\n      return tileTypeFactory(tile, x, y);\n      // const adjcentTiles = findLast(islands, island =>\n      //   findLast(island, isAdjacent(x, y))\n      // );\n      //\n      // if (adjcentTiles) {\n      //   adjcentTiles.push({ x, y, type: tileType(tile) });\n      // } else {\n      //   islands.push([{ x, y, type: tileType(tile) }]);\n      // }\n\n      // return WATER_ID;\n    })\n  );\n\n  console.log(`Min: ${min}, Max: ${max}`);\n  console.log(`<0: ${bellow0}, >0: ${above0}`);\n  console.log(`Seed: ${seed}`);\n\n  // console.log(islands.length, islands);\n\n  // sortBy(islands, \"length\")\n  //   .reverse()[0]\n  //   .forEach(({ x, y, type }) => (normalized[y][x] = type));\n  return normalized;\n};\n\nexport const toEmoji = map =>\n  map.map(row => row.map(column => (column === 0 ? \"ðŸŒŠ\" : \"ðŸŒ²\")));\n\nexport const toConsole = map =>\n  map.forEach((row, index) => {\n    console.log(`${index}: ${row.join(\"\")}`);\n  });\n","import { Scene as PhaserScene, Cameras, Input } from \"phaser\";\n\nexport default class Scene extends PhaserScene {\n  get controls() {\n    return this.mapControls;\n  }\n\n  set controls(controls) {\n    this.mapControls = controls;\n  }\n\n  get camera() {\n    return this.cameras.main;\n  }\n\n  get keyboard() {\n    return this.input.keyboard;\n  }\n\n  get width() {\n    return this.game.config.width;\n  }\n\n  get height() {\n    return this.game.config.height;\n  }\n\n  get finder() {\n    return this.pathFinder;\n  }\n\n  set finder(finder) {\n    this.pathFinder = finder;\n  }\n\n  get movement() {\n    return this.entityMover;\n  }\n\n  set movement(movement) {\n    this.entityMover = movement;\n  }\n\n  get minimap() {\n    return this.minimapCamera;\n  }\n\n  set minimap(minimap) {\n    this.minimapCamera = minimap;\n  }\n\n  get target() {\n    return this.selectedTarget;\n  }\n\n  set target(selectedTarget) {\n    this.selectedTarget = selectedTarget;\n  }\n\n  get terrainLayer() {\n    return this.terrain;\n  }\n\n  set terrainLayer(terrainLayer) {\n    this.terrain = terrainLayer;\n  }\n\n  createMapControls() {\n    const { Q, E } = Input.Keyboard.KeyCodes;\n    const { SmoothedKeyControl } = Cameras.Controls;\n    const { left, right, up, down } = this.input.keyboard.createCursorKeys();\n\n    const config = {\n      up: up,\n      down: down,\n      left: left,\n      right: right,\n      camera: this.camera,\n      zoomIn: this.keyboard.addKey(Q),\n      zoomOut: this.keyboard.addKey(E),\n      drag: 0.6,\n      maxSpeed: 200.0,\n      acceleration: 2.8\n    };\n\n    this.controls = new SmoothedKeyControl(config);\n  }\n\n  setupCamera(mapWidth, mapHeight) {\n    const { width, height } = this.camera;\n\n    this.camera.setBounds(0, 0, mapWidth, mapHeight);\n    this.camera.setScroll(\n      -(width / 2) + mapWidth / 2,\n      -(height / 2) + mapHeight / 2\n    );\n  }\n}\n","import { isEqual } from \"lodash\";\nimport { Geom } from \"phaser\";\n\nconst INITIAL_STATE = {\n  path: [],\n  cost: 0,\n  totalCost: 0,\n  currentTurn: [],\n  nextTurns: [],\n  indicators: [],\n  nextIndicators: []\n};\n\nconst pathReducer = (costMatrix, target) => (state, { x, y }) => {\n  const { cost, totalCost, currentTurn, nextTurns } = state;\n  const tileCost = costMatrix[y][x];\n\n  if (totalCost + tileCost <= target.movementPoints)\n    return {\n      ...state,\n      cost: cost + tileCost,\n      totalCost: totalCost + tileCost,\n      currentTurn: [...currentTurn, { x, y }]\n    };\n\n  return { ...state, nextTurns: [...nextTurns, { x, y }] };\n};\n\nexport default (scene, costMatrix, tileWidth, tileHeight) => {\n  let graphics = scene.add.graphics();\n  let state = INITIAL_STATE;\n\n  const worldX = value => value * tileWidth;\n  const worldY = value => value * tileHeight;\n\n  const clear = () => {\n    graphics.destroy();\n    graphics = scene.add.graphics();\n    state = INITIAL_STATE;\n  };\n\n  const createPathPoint = ({ x, y }) => {\n    const positon = {\n      x: worldX(x) + tileWidth / 2,\n      y: worldY(y) + tileHeight / 2\n    };\n    const circle = new Geom.Circle(positon.x, positon.y, 8);\n    graphics.fillCircleShape(circle);\n    return circle;\n  };\n\n  const onComplete = target => () => {\n    scene.camera.stopFollow(target.body);\n    clear();\n  };\n\n  const doMove = target => {\n    const { cost, currentTurn } = state;\n    const tweens = currentTurn.map(({ x, y }) => ({\n      targets: target.body,\n      x: { value: worldX(x), duration: 200 },\n      y: { value: worldY(y), duration: 200 }\n    }));\n\n    scene.camera.startFollow(target.body);\n    scene.tweens.timeline({ tweens, onComplete: onComplete(target) });\n\n    target.spendMovement(cost);\n  };\n\n  const move = target => path => {\n    if (!path || path.length <= 1) return clear();\n\n    if (state && state.currentTurn.length && isEqual(state.path, path))\n      return doMove(target);\n\n    clear();\n\n    const nextState = path\n      .slice(1, path.length)\n      .reduce(pathReducer(costMatrix, target), { ...INITIAL_STATE, path });\n\n    let { currentTurn, nextTurns } = nextState;\n\n    graphics.fillStyle(0xffffff, 1); // color: white\n    nextState.indicators = currentTurn.map(createPathPoint);\n\n    graphics.fillStyle(0xff0000, 1); // color: red\n    nextState.nextIndicators = nextTurns.map(createPathPoint);\n\n    state = nextState;\n  };\n\n  return { move, clear };\n};\n","const INITIAL_STATE = {\n  turn: 1,\n  name: \"\",\n  money: 0,\n  armies: [],\n  castles: []\n};\n\nclass Army {\n  constructor(scene, x, y, type) {\n    this.scene = scene;\n    this.movementPoints = 4;\n    this.body = scene.physics.add\n      .sprite(x, y, type)\n      .setDisplaySize(24, 24)\n      .setDisplayOrigin(-42, -44);\n  }\n\n  spendMovement = amount => (this.movementPoints -= amount);\n  resetMovement = () => (this.movementPoints = 4);\n}\n\nconst player = (scene, id) => {\n  let state = {\n    ...INITIAL_STATE,\n    name: `Player ${id}`\n  };\n\n  const endTurn = () => {\n    state.armies.forEach(army => army.resetMovement());\n\n    state = {\n      ...state,\n      turn: state.turn + 1\n    };\n  };\n\n  const addArmy = (x, y, type) => {\n    const newArmy = new Army(scene, x, y, type);\n    state = {\n      ...state,\n      armies: [...state.armies, newArmy]\n    };\n    return newArmy;\n  };\n\n  const name = () => state.name;\n  const turn = () => state.turn;\n\n  return {\n    state,\n    name,\n    turn,\n    endTurn,\n    addArmy\n  };\n};\n\nexport default player;\n","import { Math as PhaserMath, Scene as PhaserScene } from \"phaser\";\n\nimport generator from \"./TerrainGen\";\nimport Scene from \"./Scene\";\nimport Map from \"./Map\";\nimport Movement from \"./Movement\";\nimport Player from \"./Player\";\n\nconst MAP_WIDTH = 100;\nconst MAP_HEIGHT = 100;\nconst TILE_WIDTH = 128;\nconst TILE_HEIGHT = 128;\n// const SEED = 0.8444330836642344;\n\nconst worldToTile = (x, y) => ({\n  x: Math.floor(x / TILE_WIDTH),\n  y: Math.floor(y / TILE_HEIGHT)\n});\n\nexport default class GameScene extends Scene {\n  constructor() {\n    super(\"GameScene\");\n    this.players = [];\n  }\n\n  addPlayer() {\n    const playerId = this.players.length;\n    const newPlayer = Player(this, playerId);\n    this.players.push(newPlayer);\n    return newPlayer;\n  }\n\n  preload() {\n    this.load.setBaseURL(`${process.env.PUBLIC_URL}`);\n    this.load.image(\"tiles\", \"tilesets/tileset-extruded.png\");\n    this.load.image(\"warrior\", \"warrior.png\");\n    // this.load.tilemapTiledJSON(\"map\", \"/tilemaps/copycat.json\");\n  }\n\n  create() {\n    const world = generator(MAP_WIDTH, MAP_HEIGHT);\n    const { map, finder, costMatrix, spawnPoint, terrainLayer } = Map(\n      this,\n      world,\n      MAP_WIDTH,\n      MAP_HEIGHT\n    );\n    this.finder = finder;\n    this.terrainLayer = terrainLayer;\n    const { tileWidth, tileHeight } = map;\n\n    const player = this.addPlayer();\n    const army = player.addArmy(\n      spawnPoint.x * tileWidth,\n      spawnPoint.y * tileHeight,\n      \"warrior\"\n    );\n    army.body.setInteractive().on(\"pointerdown\", () => (this.target = army));\n    this.target = army;\n\n    this.setupCamera(terrainLayer.width, terrainLayer.height);\n    this.camera.centerOn(this.target.body.x, this.target.body.y);\n\n    this.movement = Movement(this, costMatrix, tileWidth, tileHeight);\n\n    this.createMapControls();\n    this.input.on(\"pointerdown\", this.onPointerDown);\n\n    this.scene.run(\"UI\");\n  }\n\n  onPointerDown = ({ worldX, worldY }) => {\n    if (!this.target) return;\n\n    const to = worldToTile(worldX, worldY);\n    const from = worldToTile(this.target.body.x, this.target.body.y);\n    const onPathCalculated = this.movement.move(this.target);\n\n    try {\n      this.finder.findPath(from.x, from.y, to.x, to.y, onPathCalculated);\n      this.finder.calculate();\n    } catch (error) {\n      console.error(\"Ups! Out of scope :S\");\n    }\n  };\n\n  update(time, delta) {\n    this.controls.update(delta);\n    this.camera.setZoom(PhaserMath.Clamp(this.camera.zoom, 0.08, 1));\n  }\n}\n","import EasyStar from \"easystarjs\";\nimport { includes } from \"lodash\";\n\nimport {\n  TERRAIN_ID,\n  FOREST_ID,\n  // CASTLE_ID,\n  MOUNTAIN_ID,\n  WATER_ID\n} from \"./TerrainGen\";\n\nconst setTileCost = (costMatrix, finder) => (tile, x, y, cost) => {\n  finder.setTileCost(tile, cost);\n  costMatrix[y] = costMatrix[y] || [];\n  costMatrix[y][x] = cost;\n};\n\nexport default (scene, world, width, height) => {\n  const map = scene.make.tilemap({ tileWidth: 128, tileHeight: 128 });\n  const { tileWidth, tileHeight } = map;\n  const tiles = map.addTilesetImage(\n    \"tilemap\",\n    \"tiles\",\n    tileWidth,\n    tileHeight,\n    1,\n    2\n  );\n\n  let terrainLayer = map.createBlankDynamicLayer(\n    \"terrain\",\n    tiles,\n    0,\n    0,\n    width,\n    height,\n    tileWidth,\n    tileHeight\n  );\n\n  let spawnPoint;\n\n  const finder = new EasyStar.js();\n  finder.setGrid(world);\n  finder.setAcceptableTiles([...TERRAIN_ID, ...MOUNTAIN_ID, ...FOREST_ID]);\n  finder.enableDiagonals();\n  // finder.enableCornerCutting();\n\n  const costMatrix = [];\n  const setCost = setTileCost(costMatrix, finder);\n\n  world.forEach((row, y) =>\n    row.forEach((tile, x) => {\n      if (!spawnPoint && !includes(WATER_ID, tile)) spawnPoint = { x, y };\n      terrainLayer.putTileAt(tile, x, y);\n      if (includes(TERRAIN_ID, tile)) setCost(tile, x, y, 1);\n      if (includes(FOREST_ID, tile)) setCost(tile, x, y, 2);\n      if (includes(MOUNTAIN_ID, tile)) setCost(tile, x, y, 3);\n    })\n  );\n\n  terrainLayer = map.convertLayerToStatic(terrainLayer);\n\n  return {\n    map,\n    finder,\n    costMatrix,\n    spawnPoint,\n    terrainLayer\n  };\n};\n","import Phaser, { Game } from \"phaser\";\n\n// import game from \"./Game\";\nimport UI from \"./UI\";\nimport GameScene from \"./GameScene\";\n\nconst physics = {\n  default: \"arcade\",\n  arcade: {\n    gravity: { y: 0 }\n  }\n};\n\nconst config = {\n  physics,\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  parent: \"App\",\n  pixelArt: true,\n  scene: [GameScene, UI]\n};\n\nnew Game(config);\n","import React from \"react\";\n\nimport \"./App.css\";\n\n// import \"./StaticTileMap\";\nimport \"./Game\";\n\nfunction App() {\n  return <div className=\"App\" id=\"App\"></div>;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}