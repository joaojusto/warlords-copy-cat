{"version":3,"sources":["TerrainGen.js","Scene.js","MiniMap.js","Movement.js","Player.js","GameScene.js","Map.js","DynamicTileMap.js","App.js","serviceWorker.js","index.js"],"names":["TERRAIN_ID","FOREST_ID","SAND_ID","MOUNTAIN_ID","WATER_ID","width","height","seed","Math","random","noise","Noise","zoom","min","max","bellow0","above0","matrix","range","map","y","x","value","perlin2","waterLevel","sandLevel","isSand","level","isWater","isTerrain","sandTile","length","sample","topLeft","progress","top","topRight","left","right","bottomLeft","bottom","bottomRight","tileType","tile","tileTypeFactory","normalized","row","console","log","Scene","Input","Keyboard","KeyCodes","Q","E","SmoothedKeyControl","Cameras","Controls","this","input","keyboard","createCursorKeys","config","up","down","camera","zoomIn","addKey","zoomOut","drag","maxSpeed","acceleration","controls","mapWidth","mapHeight","setBounds","setScroll","mapControls","cameras","main","game","pathFinder","finder","entityMover","movement","minimapCamera","minimap","selectedTarget","PhaserScene","CONFIG","INITIAL_STATE","path","cost","totalCost","currentTurn","nextTurns","indicators","nextIndicators","scene","costMatrix","tileWidth","tileHeight","graphics","add","state","worldX","worldY","clear","destroy","createPathPoint","positon","circle","Geom","Circle","fillCircleShape","onComplete","target","stopFollow","body","move","isEqual","tweens","targets","duration","startFollow","timeline","spendMovement","doMove","nextState","slice","reduce","tileCost","movementPoints","pathReducer","fillStyle","turn","name","money","armies","castles","Army","type","amount","resetMovement","physics","sprite","setDisplaySize","setDisplayOrigin","player","id","endTurn","forEach","army","addArmy","newArmy","worldToTile","floor","GameScene","arguments","onPointerDown","to","from","onPathCalculated","findPath","calculate","error","players","playerId","newPlayer","Player","push","load","setBaseURL","process","image","world","spawnPoint","make","tilemap","tiles","addTilesetImage","terrainLayer","createBlankDynamicLayer","EasyStar","js","setGrid","setAcceptableTiles","enableDiagonals","setCost","setTileCost","includes","putTileAt","convertLayerToStatic","Map","generator","addPlayer","margin","background","center","setZoom","setName","centerOn","setBackgroundColor","MiniMap","setupCamera","Movement","createMapControls","on","title","text","fill","setScrollFactor","setInteractive","setText","time","delta","update","PhaserMath","Clamp","default","arcade","gravity","Phaser","AUTO","parent","pixelArt","Game","App","className","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.273a7ac5.chunk.js","sourcesContent":["import { Noise } from \"noisejs\";\nimport { findLast, range, sample, sortBy } from \"lodash\";\nimport { progress } from \"@popmotion/popcorn\";\n\nexport const TERRAIN_ID = [2];\nexport const FOREST_ID = [4, 5, 6];\nexport const SAND_ID = [8, 9, 10, 11, 12, 13, 14, 15];\nexport const CASTLE_ID = [];\nexport const MOUNTAIN_ID = [1];\nexport const WATER_ID = [3, 7];\n\nconst ZOOM_FACTOR = 12;\n\nexport default (width, height, seed = Math.random()) => {\n  const noise = new Noise();\n  noise.seed(seed);\n  const zoom = (width * ZOOM_FACTOR) / 100;\n\n  let min = 0;\n  let max = 0;\n  let bellow0 = 0;\n  let above0 = 0;\n\n  const matrix = range(height).map(y => {\n    return range(width).map(x => {\n      const value = noise.perlin2(x / zoom, y / zoom);\n\n      min = value < min ? value : min;\n      max = value > max ? value : max;\n\n      if (value < 0) bellow0++;\n      else above0++;\n\n      return value;\n    });\n  });\n\n  // let islands = [];\n\n  // const border = 0.2;\n  const waterLevel = 0.45;\n  const sandLevel = waterLevel + 0.1;\n\n  // const isAdjacent = (x, y) => island =>\n  //   (x + 1 === island.x || x - 1 === island.x || x === island.x) &&\n  //   (y + 1 === island.y || y - 1 === island.y || y === island.y);\n\n  const isSand = level => level >= waterLevel && level < sandLevel;\n  const isWater = level => level < waterLevel;\n  const isTerrain = level => !isSand(level) && !isWater(level);\n\n  const sandTile = (matrix, x, y) => {\n    if (y - 1 < 0 || y + 1 >= matrix.length) return sample(WATER_ID);\n    if (x - 1 < 0 || x + 1 >= matrix.length) return sample(WATER_ID);\n\n    const topLeft = progress(min, max, matrix[y - 1][x - 1]);\n    const top = progress(min, max, matrix[y - 1][x]);\n    const topRight = progress(min, max, matrix[y - 1][x + 1]);\n    const left = progress(min, max, matrix[y][x - 1]);\n    const right = progress(min, max, matrix[y][x + 1]);\n    const bottomLeft = progress(min, max, matrix[y + 1][x - 1]);\n    const bottom = progress(min, max, matrix[y + 1][x]);\n    const bottomRight = progress(min, max, matrix[y + 1][x + 1]);\n\n    if (\n      !isTerrain(top) &&\n      !isTerrain(left) &&\n      !isTerrain(right) &&\n      !isTerrain(bottom)\n    )\n      return sample(WATER_ID);\n\n    if (isTerrain(bottom) && isTerrain(right)) return SAND_ID[7];\n    if (isTerrain(top) && isTerrain(right)) return SAND_ID[2];\n    if (isTerrain(bottom) && isTerrain(left)) return SAND_ID[5];\n    if (isTerrain(top) && isTerrain(left)) return SAND_ID[0];\n\n    if (isTerrain(top)) return SAND_ID[1];\n    if (isTerrain(bottom)) return SAND_ID[6];\n    if (isTerrain(right)) return SAND_ID[3];\n    if (isTerrain(left)) return SAND_ID[4];\n\n    if (topLeft < waterLevel && top < waterLevel && topRight < waterLevel) {\n      return SAND_ID[6];\n    }\n\n    if (\n      bottomLeft < waterLevel &&\n      bottom < waterLevel &&\n      bottomRight < waterLevel\n    ) {\n      return SAND_ID[1];\n    }\n  };\n\n  const tileType = matrix => (tile, x, y) => {\n    const value = progress(min, max, tile);\n    if (isWater(value)) return sample(WATER_ID);\n    if (isSand(value)) return sandTile(matrix, x, y);\n    // if (value >= 0.6 && value < 0.61) return sample(CASTLE_ID);\n    if (value >= 0.7 && value < 0.8) return sample(FOREST_ID);\n    if (value >= 0.8) return sample(MOUNTAIN_ID);\n    return sample(TERRAIN_ID);\n  };\n\n  const tileTypeFactory = tileType(matrix);\n\n  const normalized = matrix.map((row, y) =>\n    row.map((tile, x) => {\n      // if (y < height * border || y > height * (1 - border)) return WATER_ID;\n      // if (x < width * border || x > width * (1 - border)) return WATER_ID;\n\n      // const value = progress(min, max, tile);\n      // if (value < waterLevel) return WATER_ID;\n\n      return tileTypeFactory(tile, x, y);\n      // const adjcentTiles = findLast(islands, island =>\n      //   findLast(island, isAdjacent(x, y))\n      // );\n      //\n      // if (adjcentTiles) {\n      //   adjcentTiles.push({ x, y, type: tileType(tile) });\n      // } else {\n      //   islands.push([{ x, y, type: tileType(tile) }]);\n      // }\n\n      // return WATER_ID;\n    })\n  );\n\n  console.log(`Min: ${min}, Max: ${max}`);\n  console.log(`<0: ${bellow0}, >0: ${above0}`);\n  console.log(`Seed: ${seed}`);\n\n  // console.log(islands.length, islands);\n\n  // sortBy(islands, \"length\")\n  //   .reverse()[0]\n  //   .forEach(({ x, y, type }) => (normalized[y][x] = type));\n  return normalized;\n};\n\nexport const toEmoji = map =>\n  map.map(row => row.map(column => (column === 0 ? \"ðŸŒŠ\" : \"ðŸŒ²\")));\n\nexport const toConsole = map =>\n  map.forEach((row, index) => {\n    console.log(`${index}: ${row.join(\"\")}`);\n  });\n","import { Scene as PhaserScene, Cameras, Input } from \"phaser\";\n\nexport default class Scene extends PhaserScene {\n  get controls() {\n    return this.mapControls;\n  }\n\n  set controls(controls) {\n    this.mapControls = controls;\n  }\n\n  get camera() {\n    return this.cameras.main;\n  }\n\n  get keyboard() {\n    return this.input.keyboard;\n  }\n\n  get width() {\n    return this.game.config.width;\n  }\n\n  get height() {\n    return this.game.config.height;\n  }\n\n  get finder() {\n    return this.pathFinder;\n  }\n\n  set finder(finder) {\n    this.pathFinder = finder;\n  }\n\n  get movement() {\n    return this.entityMover;\n  }\n\n  set movement(movement) {\n    this.entityMover = movement;\n  }\n\n  get minimap() {\n    return this.minimapCamera;\n  }\n\n  set minimap(minimap) {\n    this.minimapCamera = minimap;\n  }\n\n  get target() {\n    return this.selectedTarget;\n  }\n\n  set target(selectedTarget) {\n    this.selectedTarget = selectedTarget;\n  }\n\n  createMapControls() {\n    const { Q, E } = Input.Keyboard.KeyCodes;\n    const { SmoothedKeyControl } = Cameras.Controls;\n    const { left, right, up, down } = this.input.keyboard.createCursorKeys();\n\n    const config = {\n      up: up,\n      down: down,\n      left: left,\n      right: right,\n      camera: this.camera,\n      zoomIn: this.keyboard.addKey(Q),\n      zoomOut: this.keyboard.addKey(E),\n      drag: 0.6,\n      maxSpeed: 200.0,\n      acceleration: 2.8\n    };\n\n    this.controls = new SmoothedKeyControl(config);\n  }\n\n  setupCamera(mapWidth, mapHeight) {\n    const { width, height } = this.camera;\n\n    this.camera.setBounds(0, 0, mapWidth, mapHeight);\n    this.camera.setScroll(\n      -(width / 2) + mapWidth / 2,\n      -(height / 2) + mapHeight / 2\n    );\n  }\n}\n","const CONFIG = {\n  width: 102,\n  height: 102,\n  margin: 10,\n  padding: 2,\n  background: 0x002244,\n  name: \"minimap\"\n};\n\nexport default (scene, mapWidth, mapHeight) => {\n  const { width, height, margin, padding, name, background } = CONFIG;\n\n  const zoom = (height - padding) / mapHeight;\n  const center = { x: mapWidth / 2, y: mapHeight / 2 };\n  const positon = { x: scene.width - width - margin, y: margin };\n\n  return scene.cameras\n    .add(positon.x, positon.y, width, height)\n    .setZoom(zoom)\n    .setName(name)\n    .centerOn(center.x, center.y)\n    .setBackgroundColor(background);\n};\n","import { isEqual } from \"lodash\";\nimport { Geom } from \"phaser\";\n\nconst INITIAL_STATE = {\n  path: [],\n  cost: 0,\n  totalCost: 0,\n  currentTurn: [],\n  nextTurns: [],\n  indicators: [],\n  nextIndicators: []\n};\n\nconst pathReducer = (costMatrix, target) => (state, { x, y }) => {\n  const { cost, totalCost, currentTurn, nextTurns } = state;\n  const tileCost = costMatrix[y][x];\n\n  if (totalCost + tileCost <= target.movementPoints)\n    return {\n      ...state,\n      cost: cost + tileCost,\n      totalCost: totalCost + tileCost,\n      currentTurn: [...currentTurn, { x, y }]\n    };\n\n  return { ...state, nextTurns: [...nextTurns, { x, y }] };\n};\n\nexport default (scene, costMatrix, tileWidth, tileHeight) => {\n  let graphics = scene.add.graphics();\n  let state = INITIAL_STATE;\n\n  const worldX = value => value * tileWidth;\n  const worldY = value => value * tileHeight;\n\n  const clear = () => {\n    graphics.destroy();\n    graphics = scene.add.graphics();\n    state = INITIAL_STATE;\n  };\n\n  const createPathPoint = ({ x, y }) => {\n    const positon = {\n      x: worldX(x) + tileWidth / 2,\n      y: worldY(y) + tileHeight / 2\n    };\n    const circle = new Geom.Circle(positon.x, positon.y, 8);\n    graphics.fillCircleShape(circle);\n    return circle;\n  };\n\n  const onComplete = target => () => {\n    scene.camera.stopFollow(target.body);\n    clear();\n  };\n\n  const doMove = target => {\n    const { cost, currentTurn } = state;\n    const tweens = currentTurn.map(({ x, y }) => ({\n      targets: target.body,\n      x: { value: worldX(x), duration: 200 },\n      y: { value: worldY(y), duration: 200 }\n    }));\n\n    scene.camera.startFollow(target.body);\n    scene.tweens.timeline({ tweens, onComplete: onComplete(target) });\n\n    target.spendMovement(cost);\n  };\n\n  const move = target => path => {\n    if (!path || path.length <= 1) return clear();\n\n    if (state && state.currentTurn.length && isEqual(state.path, path))\n      return doMove(target);\n\n    clear();\n\n    const nextState = path\n      .slice(1, path.length)\n      .reduce(pathReducer(costMatrix, target), { ...INITIAL_STATE, path });\n\n    let { currentTurn, nextTurns } = nextState;\n\n    graphics.fillStyle(0xffffff, 1); // color: white\n    nextState.indicators = currentTurn.map(createPathPoint);\n\n    graphics.fillStyle(0xff0000, 1); // color: red\n    nextState.nextIndicators = nextTurns.map(createPathPoint);\n\n    state = nextState;\n  };\n\n  return { move, clear };\n};\n","const INITIAL_STATE = {\n  turn: 1,\n  name: \"\",\n  money: 0,\n  armies: [],\n  castles: []\n};\n\nclass Army {\n  constructor(scene, x, y, type) {\n    this.scene = scene;\n    this.movementPoints = 4;\n    this.body = scene.physics.add\n      .sprite(x, y, type)\n      .setDisplaySize(24, 24)\n      .setDisplayOrigin(-42, -44);\n  }\n\n  spendMovement = amount => (this.movementPoints -= amount);\n  resetMovement = () => (this.movementPoints = 4);\n}\n\nconst player = (scene, id) => {\n  let state = {\n    ...INITIAL_STATE,\n    name: `Player ${id}`\n  };\n\n  const endTurn = () => {\n    state.armies.forEach(army => army.resetMovement());\n\n    state = {\n      ...state,\n      turn: state.turn + 1\n    };\n  };\n\n  const addArmy = (x, y, type) => {\n    const newArmy = new Army(scene, x, y, type);\n    state = {\n      ...state,\n      armies: [...state.armies, newArmy]\n    };\n    return newArmy;\n  };\n\n  const name = () => state.name;\n  const turn = () => state.turn;\n\n  return {\n    state,\n    name,\n    turn,\n    endTurn,\n    addArmy\n  };\n};\n\nexport default player;\n","import { Math as PhaserMath } from \"phaser\";\n\nimport generator from \"./TerrainGen\";\nimport Scene from \"./Scene\";\nimport Map from \"./Map\";\nimport MiniMap from \"./MiniMap\";\nimport Movement from \"./Movement\";\nimport Player from \"./Player\";\n\nconst MAP_WIDTH = 100;\nconst MAP_HEIGHT = 100;\nconst TILE_WIDTH = 128;\nconst TILE_HEIGHT = 128;\n// const SEED = 0.8444330836642344;\n\nconst worldToTile = (x, y) => ({\n  x: Math.floor(x / TILE_WIDTH),\n  y: Math.floor(y / TILE_HEIGHT)\n});\n\nexport default class GameScene extends Scene {\n  constructor() {\n    super(arguments);\n    this.players = [];\n  }\n\n  addPlayer() {\n    const playerId = this.players.length;\n    const newPlayer = Player(this, playerId);\n    this.players.push(newPlayer);\n    return newPlayer;\n  }\n\n  preload() {\n    this.load.setBaseURL(`${process.env.PUBLIC_URL}`);\n    this.load.image(\"tiles\", \"tilesets/tileset-extruded.png\");\n    this.load.image(\"warrior\", \"warrior.png\");\n    // this.load.tilemapTiledJSON(\"map\", \"/tilemaps/copycat.json\");\n  }\n\n  create() {\n    const world = generator(MAP_WIDTH, MAP_HEIGHT);\n    const { map, finder, costMatrix, spawnPoint, terrainLayer } = Map(\n      this,\n      world,\n      MAP_WIDTH,\n      MAP_HEIGHT\n    );\n    this.finder = finder;\n    const { tileWidth, tileHeight } = map;\n\n    const player = this.addPlayer();\n    this.target = player.addArmy(\n      spawnPoint.x * tileWidth,\n      spawnPoint.y * tileHeight,\n      \"warrior\"\n    );\n\n    this.minimap = MiniMap(this, terrainLayer.width, terrainLayer.height);\n    this.setupCamera(terrainLayer.width, terrainLayer.height);\n    this.camera.centerOn(this.target.body.x, this.target.body.y);\n\n    this.movement = Movement(this, costMatrix, tileWidth, tileHeight);\n\n    this.createMapControls();\n    this.input.on(\"pointerdown\", this.onPointerDown);\n\n    const title = this.add\n      .text(\n        20,\n        20,\n        `Current Player: ${player.name()}, turn: ${player.turn()}`,\n        { fill: \"#000000\" }\n      )\n      .setScrollFactor(0);\n\n    const button = this.add\n      .text(700, 560, `End Turn`, { fill: \"#000000\" })\n      .setScrollFactor(0)\n      .setInteractive()\n      .on(\"pointerdown\", () => {\n        player.endTurn();\n        title.setText(\n          `Current Player: ${player.name()}, turn: ${player.turn()}`\n        );\n      });\n  }\n\n  onPointerDown = ({ worldX, worldY }) => {\n    const to = worldToTile(worldX, worldY);\n    const from = worldToTile(this.target.body.x, this.target.body.y);\n    const onPathCalculated = this.movement.move(this.target);\n\n    try {\n      this.finder.findPath(from.x, from.y, to.x, to.y, onPathCalculated);\n      this.finder.calculate();\n    } catch (error) {\n      console.error(\"Ups! Out of scope :S\");\n    }\n  };\n\n  update(time, delta) {\n    this.controls.update(delta);\n    this.camera.setZoom(PhaserMath.Clamp(this.camera.zoom, 0.08, 1));\n  }\n}\n","import EasyStar from \"easystarjs\";\nimport { includes } from \"lodash\";\n\nimport {\n  TERRAIN_ID,\n  FOREST_ID,\n  // CASTLE_ID,\n  MOUNTAIN_ID,\n  WATER_ID\n} from \"./TerrainGen\";\n\nconst setTileCost = (costMatrix, finder) => (tile, x, y, cost) => {\n  finder.setTileCost(tile, cost);\n  costMatrix[y] = costMatrix[y] || [];\n  costMatrix[y][x] = cost;\n};\n\nexport default (scene, world, width, height) => {\n  const map = scene.make.tilemap({ tileWidth: 128, tileHeight: 128 });\n  const { tileWidth, tileHeight } = map;\n  const tiles = map.addTilesetImage(\n    \"tilemap\",\n    \"tiles\",\n    tileWidth,\n    tileHeight,\n    1,\n    2\n  );\n\n  let terrainLayer = map.createBlankDynamicLayer(\n    \"terrain\",\n    tiles,\n    0,\n    0,\n    width,\n    height,\n    tileWidth,\n    tileHeight\n  );\n\n  let spawnPoint;\n\n  const finder = new EasyStar.js();\n  finder.setGrid(world);\n  finder.setAcceptableTiles([...TERRAIN_ID, ...MOUNTAIN_ID, ...FOREST_ID]);\n  finder.enableDiagonals();\n  // finder.enableCornerCutting();\n\n  const costMatrix = [];\n  const setCost = setTileCost(costMatrix, finder);\n\n  world.forEach((row, y) =>\n    row.forEach((tile, x) => {\n      if (!spawnPoint && !includes(WATER_ID, tile)) spawnPoint = { x, y };\n      terrainLayer.putTileAt(tile, x, y);\n      if (includes(TERRAIN_ID, tile)) setCost(tile, x, y, 1);\n      if (includes(FOREST_ID, tile)) setCost(tile, x, y, 2);\n      if (includes(MOUNTAIN_ID, tile)) setCost(tile, x, y, 3);\n    })\n  );\n\n  terrainLayer = map.convertLayerToStatic(terrainLayer);\n\n  return {\n    map,\n    finder,\n    costMatrix,\n    spawnPoint,\n    terrainLayer\n  };\n};\n","import Phaser, { Game } from \"phaser\";\n\nimport game from \"./Game\";\nimport GameScene from \"./GameScene\";\n\nconst physics = {\n  default: \"arcade\",\n  arcade: {\n    gravity: { y: 0 }\n  }\n};\n\nconst config = {\n  physics,\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  parent: \"App\",\n  pixelArt: true,\n  scene: GameScene\n};\n\nnew Game(config);\n","import React from \"react\";\n\nimport \"./App.css\";\n\n// import \"./StaticTileMap\";\nimport \"./DynamicTileMap\";\n\nfunction App() {\n  return <div className=\"App\" id=\"App\"></div>;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}