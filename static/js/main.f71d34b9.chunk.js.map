{"version":3,"sources":["MiniMap.js","UI.js","TerrainGen.js","Scene.js","Movement.js","Army.js","Player.js","GameScene.js","Map.js","Game.js","App.js","index.js"],"names":["CONFIG","UI","Scene","call","key","active","game","this","scene","get","mapWidth","mapHeight","width","height","margin","name","background","zoom","center","x","y","positon","cameras","add","setZoom","setName","centerOn","setBackgroundColor","MiniMap","terrainLayer","player","players","title","text","turn","fill","setInteractive","on","target","movement","clear","endTurn","setText","TERRAIN_ID","FOREST_ID","SAND_ID","CASTLE_ID","MOUNTAIN_ID","WATER_ID","Input","Keyboard","KeyCodes","Q","E","SmoothedKeyControl","Cameras","Controls","input","keyboard","createCursorKeys","left","right","config","up","down","camera","zoomIn","addKey","zoomOut","drag","maxSpeed","acceleration","controls","setBounds","setScroll","mapControls","main","pathFinder","finder","entityMover","minimapCamera","minimap","selectedTarget","terrain","PhaserScene","INITIAL_STATE","path","cost","totalCost","currentTurn","nextTurns","indicators","nextIndicators","costMatrix","tileWidth","tileHeight","graphics","state","worldX","value","worldY","destroy","createPathPoint","circle","Geom","Circle","fillCircleShape","onComplete","stopFollow","body","move","length","isEqual","tweens","map","targets","duration","startFollow","timeline","spendMovement","doMove","nextState","slice","reduce","tileCost","movementPoints","pathReducer","fillStyle","Army","type","amount","resetMovement","update","embedded","touching","none","wasTouching","emit","physics","sprite","setDisplaySize","setDisplayOrigin","onCastle","debugBodyColor","alert","triggers","forEach","trigger","overlap","money","armies","castles","id","army","addArmy","newArmy","worldToTile","Math","floor","GameScene","onPointerDown","to","from","onPathCalculated","findPath","calculate","error","console","playerId","newPlayer","Player","push","load","setBaseURL","process","image","world","spawnPoint","make","tilemap","tileset","addTilesetImage","createBlankDynamicLayer","objectLayer","EasyStar","js","setGrid","setAcceptableTiles","enableDiagonals","setCost","tile","setTileCost","row","includes","putTileAt","zone","setSize","enable","setAllowGravity","moves","convertLayerToStatic","setTileIndexCallback","log","Map","seed","random","noise","Noise","min","max","bellow0","above0","matrix","range","perlin2","waterLevel","sandLevel","isSand","level","isWater","isTerrain","sandTile","sample","topLeft","progress","top","topRight","bottomLeft","bottom","bottomRight","tileType","tileTypeFactory","normalized","fitsCastle","possiblePositions","flatMap","filter","distance","a","b","abs","placeCastle","outsideRadious","points","point","radious","every","existingPoint","findCastlePosition","index","outside","placeCastles","r","generator","spawn","addPlayer","setupCamera","Movement","createMapControls","run","time","delta","PhaserMath","Clamp","default","arcade","debug","gravity","Phaser","AUTO","parent","pixelArt","Game","App","className","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f71d34b9.chunk.js","sourcesContent":["const CONFIG = {\n  width: 102,\n  height: 102,\n  margin: 10,\n  padding: 2,\n  background: 0x002244,\n  name: \"minimap\"\n};\n\nexport default (scene, mapWidth, mapHeight) => {\n  const { width, height, margin, padding, name, background } = CONFIG;\n\n  const zoom = (height - padding) / mapHeight;\n  const center = { x: mapWidth / 2, y: mapHeight / 2 };\n  const positon = { x: scene.width - width - margin, y: margin };\n\n  return scene.cameras\n    .add(positon.x, positon.y, width, height)\n    .setZoom(zoom)\n    .setName(name)\n    .centerOn(center.x, center.y)\n    .setBackgroundColor(background);\n};\n","import { Scene } from \"phaser\";\n\nimport MiniMap from \"./MiniMap\";\n\nexport default class UI extends Scene {\n  constructor() {\n    super(\"UIScene\");\n    Scene.call(this, { key: \"UI\", active: false });\n  }\n\n  create() {\n    const game = this.scene.get(\"GameScene\");\n    MiniMap(game, game.terrainLayer.width, game.terrainLayer.height);\n\n    const player = game.players[0];\n\n    const title = this.add.text(\n      20,\n      20,\n      `Current Player: ${player.name()}, turn: ${player.turn()}`,\n      { fill: \"#000000\" }\n    );\n\n    const button = this.add\n      .text(700, 560, `End Turn`, { fill: \"#000000\" })\n      .setInteractive()\n      .on(\"pointerdown\", () => {\n        game.target = null;\n        game.movement.clear();\n        player.endTurn();\n        title.setText(\n          `Current Player: ${player.name()}, turn: ${player.turn()}`\n        );\n      });\n  }\n}\n","import { Noise } from \"noisejs\";\nimport {\n  findLast,\n  range,\n  sample,\n  sortBy,\n  includes,\n  every,\n  filter\n} from \"lodash\";\nimport { progress } from \"@popmotion/popcorn\";\n\nexport const TERRAIN_ID = [2];\nexport const FOREST_ID = [4, 5, 6];\nexport const SAND_ID = [8, 9, 10, 11, 12, 13, 14, 15];\nexport const CASTLE_ID = [16, 17, 24, 25];\nexport const MOUNTAIN_ID = [1];\nexport const WATER_ID = [3, 7];\n\nconst ZOOM_FACTOR = 12;\n\nexport default (width, height, seed = Math.random()) => {\n  const noise = new Noise();\n  noise.seed(seed);\n  const zoom = (width * ZOOM_FACTOR) / 100;\n\n  let min = 0;\n  let max = 0;\n  let bellow0 = 0;\n  let above0 = 0;\n\n  const matrix = range(height).map(y => {\n    return range(width).map(x => {\n      const value = noise.perlin2(x / zoom, y / zoom);\n\n      min = value < min ? value : min;\n      max = value > max ? value : max;\n\n      if (value < 0) bellow0++;\n      else above0++;\n\n      return value;\n    });\n  });\n\n  // let islands = [];\n\n  // const border = 0.2;\n  const waterLevel = 0.45;\n  const sandLevel = waterLevel + 0.1;\n\n  // const isAdjacent = (x, y) => island =>\n  //   (x + 1 === island.x || x - 1 === island.x || x === island.x) &&\n  //   (y + 1 === island.y || y - 1 === island.y || y === island.y);\n\n  const isSand = level => level >= waterLevel && level < sandLevel;\n  const isWater = level => level < waterLevel;\n  const isTerrain = level => !isSand(level) && !isWater(level);\n\n  const sandTile = (matrix, x, y) => {\n    if (y - 1 < 0 || y + 1 >= matrix.length) return sample(WATER_ID);\n    if (x - 1 < 0 || x + 1 >= matrix.length) return sample(WATER_ID);\n\n    const topLeft = progress(min, max, matrix[y - 1][x - 1]);\n    const top = progress(min, max, matrix[y - 1][x]);\n    const topRight = progress(min, max, matrix[y - 1][x + 1]);\n    const left = progress(min, max, matrix[y][x - 1]);\n    const right = progress(min, max, matrix[y][x + 1]);\n    const bottomLeft = progress(min, max, matrix[y + 1][x - 1]);\n    const bottom = progress(min, max, matrix[y + 1][x]);\n    const bottomRight = progress(min, max, matrix[y + 1][x + 1]);\n\n    if (\n      !isTerrain(top) &&\n      !isTerrain(left) &&\n      !isTerrain(right) &&\n      !isTerrain(bottom)\n    )\n      return sample(WATER_ID);\n\n    if (isTerrain(bottom) && isTerrain(right)) return SAND_ID[7];\n    if (isTerrain(top) && isTerrain(right)) return SAND_ID[2];\n    if (isTerrain(bottom) && isTerrain(left)) return SAND_ID[5];\n    if (isTerrain(top) && isTerrain(left)) return SAND_ID[0];\n\n    if (isTerrain(top)) return SAND_ID[1];\n    if (isTerrain(bottom)) return SAND_ID[6];\n    if (isTerrain(right)) return SAND_ID[3];\n    if (isTerrain(left)) return SAND_ID[4];\n\n    if (topLeft < waterLevel && top < waterLevel && topRight < waterLevel) {\n      return SAND_ID[6];\n    }\n\n    if (\n      bottomLeft < waterLevel &&\n      bottom < waterLevel &&\n      bottomRight < waterLevel\n    ) {\n      return SAND_ID[1];\n    }\n  };\n\n  const tileType = matrix => (tile, x, y) => {\n    const value = progress(min, max, tile);\n    if (isWater(value)) return sample(WATER_ID);\n    if (isSand(value)) return sandTile(matrix, x, y);\n    // if (value >= 0.6 && value < 0.61) return sample(CASTLE_ID);\n    if (value >= 0.7 && value < 0.8) return sample(FOREST_ID);\n    if (value >= 0.8) return sample(MOUNTAIN_ID);\n    return sample(TERRAIN_ID);\n  };\n\n  const tileTypeFactory = tileType(matrix);\n\n  const normalized = matrix.map((row, y) =>\n    row.map((tile, x) => {\n      // if (y < height * border || y > height * (1 - border)) return WATER_ID;\n      // if (x < width * border || x > width * (1 - border)) return WATER_ID;\n\n      // const value = progress(min, max, tile);\n      // if (value < waterLevel) return WATER_ID;\n\n      return tileTypeFactory(tile, x, y);\n      // const adjcentTiles = findLast(islands, island =>\n      //   findLast(island, isAdjacent(x, y))\n      // );\n      //\n      // if (adjcentTiles) {\n      //   adjcentTiles.push({ x, y, type: tileType(tile) });\n      // } else {\n      //   islands.push([{ x, y, type: tileType(tile) }]);\n      // }\n\n      // return WATER_ID;\n    })\n  );\n\n  const randomTile = () => {\n    const x = Math.floor(Math.random() * width);\n    const y = Math.floor(Math.random() * height);\n    return { x, y };\n  };\n\n  const fitsCastle = ({ x, y }) => {\n    if (y - 1 < 0 || x - 1 < 0) return false;\n\n    const topLeft = normalized[y - 1][x - 1];\n    const topRight = normalized[y - 1][x];\n    const left = normalized[y][x - 1];\n    const right = normalized[y][x];\n\n    const isTerrain = value => includes(TERRAIN_ID, value);\n\n    return (\n      isTerrain(topLeft) &&\n      isTerrain(topRight) &&\n      isTerrain(left) &&\n      isTerrain(right)\n    );\n  };\n\n  const possiblePositions = normalized\n    .flatMap((row, y) => row.map((tile, x) => ({ x, y })))\n    .filter(fitsCastle);\n\n  const distance = (a, b) => Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n\n  const placeCastle = ({ x, y }) => {\n    normalized[y - 1][x - 1] = CASTLE_ID[0];\n    normalized[y - 1][x] = CASTLE_ID[1];\n    normalized[y][x - 1] = CASTLE_ID[2];\n    normalized[y][x] = CASTLE_ID[3];\n\n    return { x, y };\n  };\n\n  const outsideRadious = (points, point, radious) =>\n    every(points, existingPoint => distance(existingPoint, point) > radious);\n\n  const findCastlePosition = radious => (points, index) => {\n    let point = sample(possiblePositions);\n    let outside = outsideRadious(points, point, radious);\n\n    while (!outside) {\n      point = sample(possiblePositions);\n      outside = outsideRadious(points, point, radious);\n    }\n\n    return [...points, point];\n  };\n\n  const placeCastles = () => {\n    const amount = 20;\n    const exclusionRadious = 20;\n    const r = range(amount)\n      .reduce(findCastlePosition(exclusionRadious), [])\n      .map(placeCastle);\n\n    console.log(r.length);\n    console.log(r);\n\n    return r;\n  };\n\n  placeCastles();\n\n  console.log(`Min: ${min}, Max: ${max}`);\n  console.log(`<0: ${bellow0}, >0: ${above0}`);\n  console.log(`Seed: ${seed}`);\n\n  // console.log(islands.length, islands);\n  // sortBy(islands, \"length\")\n  //   .reverse()[0]\n  //   .forEach(({ x, y, type }) => (normalized[y][x] = type));\n  return normalized;\n};\n\nexport const toEmoji = map =>\n  map.map(row => row.map(column => (column === 0 ? \"🌊\" : \"🌲\")));\n\nexport const toConsole = map =>\n  map.forEach((row, index) => {\n    console.log(`${index}: ${row.join(\"\")}`);\n  });\n","import { Scene as PhaserScene, Cameras, Input } from \"phaser\";\n\nexport default class Scene extends PhaserScene {\n  get controls() {\n    return this.mapControls;\n  }\n\n  set controls(controls) {\n    this.mapControls = controls;\n  }\n\n  get camera() {\n    return this.cameras.main;\n  }\n\n  get keyboard() {\n    return this.input.keyboard;\n  }\n\n  get width() {\n    return this.game.config.width;\n  }\n\n  get height() {\n    return this.game.config.height;\n  }\n\n  get finder() {\n    return this.pathFinder;\n  }\n\n  set finder(finder) {\n    this.pathFinder = finder;\n  }\n\n  get movement() {\n    return this.entityMover;\n  }\n\n  set movement(movement) {\n    this.entityMover = movement;\n  }\n\n  get minimap() {\n    return this.minimapCamera;\n  }\n\n  set minimap(minimap) {\n    this.minimapCamera = minimap;\n  }\n\n  get target() {\n    return this.selectedTarget;\n  }\n\n  set target(selectedTarget) {\n    this.selectedTarget = selectedTarget;\n  }\n\n  get terrainLayer() {\n    return this.terrain;\n  }\n\n  set terrainLayer(terrainLayer) {\n    this.terrain = terrainLayer;\n  }\n\n  createMapControls() {\n    const { Q, E } = Input.Keyboard.KeyCodes;\n    const { SmoothedKeyControl } = Cameras.Controls;\n    const { left, right, up, down } = this.input.keyboard.createCursorKeys();\n\n    const config = {\n      up: up,\n      down: down,\n      left: left,\n      right: right,\n      camera: this.camera,\n      zoomIn: this.keyboard.addKey(Q),\n      zoomOut: this.keyboard.addKey(E),\n      drag: 0.6,\n      maxSpeed: 200.0,\n      acceleration: 2.8\n    };\n\n    this.controls = new SmoothedKeyControl(config);\n  }\n\n  setupCamera(mapWidth, mapHeight) {\n    const { width, height } = this.camera;\n\n    this.camera.setBounds(0, 0, mapWidth, mapHeight);\n    this.camera.setScroll(\n      -(width / 2) + mapWidth / 2,\n      -(height / 2) + mapHeight / 2\n    );\n  }\n}\n","import { isEqual } from \"lodash\";\nimport { Geom } from \"phaser\";\n\nconst INITIAL_STATE = {\n  path: [],\n  cost: 0,\n  totalCost: 0,\n  currentTurn: [],\n  nextTurns: [],\n  indicators: [],\n  nextIndicators: []\n};\n\nconst pathReducer = (costMatrix, target) => (state, { x, y }) => {\n  const { cost, totalCost, currentTurn, nextTurns } = state;\n  const tileCost = costMatrix[y][x];\n\n  if (totalCost + tileCost <= target.movementPoints)\n    return {\n      ...state,\n      cost: cost + tileCost,\n      totalCost: totalCost + tileCost,\n      currentTurn: [...currentTurn, { x, y }]\n    };\n\n  return { ...state, nextTurns: [...nextTurns, { x, y }] };\n};\n\nexport default (scene, costMatrix, tileWidth, tileHeight) => {\n  let graphics = scene.add.graphics();\n  let state = INITIAL_STATE;\n\n  const worldX = value => value * tileWidth;\n  const worldY = value => value * tileHeight;\n\n  const clear = () => {\n    graphics.destroy();\n    graphics = scene.add.graphics();\n    state = INITIAL_STATE;\n  };\n\n  const createPathPoint = ({ x, y }) => {\n    const positon = {\n      x: worldX(x) + tileWidth / 2,\n      y: worldY(y) + tileHeight / 2\n    };\n    const circle = new Geom.Circle(positon.x, positon.y, 8);\n    graphics.fillCircleShape(circle);\n    return circle;\n  };\n\n  const onComplete = target => () => {\n    scene.camera.stopFollow(target.body);\n    clear();\n  };\n\n  const doMove = target => {\n    const { cost, currentTurn } = state;\n    const tweens = currentTurn.map(({ x, y }) => ({\n      targets: target.body,\n      x: { value: worldX(x), duration: 200 },\n      y: { value: worldY(y), duration: 200 }\n    }));\n\n    scene.camera.startFollow(target.body);\n    scene.tweens.timeline({ tweens, onComplete: onComplete(target) });\n\n    target.spendMovement(cost);\n  };\n\n  const move = target => path => {\n    if (!path || path.length <= 1) return clear();\n\n    if (state && state.currentTurn.length && isEqual(state.path, path))\n      return doMove(target);\n\n    clear();\n\n    const nextState = path\n      .slice(1, path.length)\n      .reduce(pathReducer(costMatrix, target), { ...INITIAL_STATE, path });\n\n    let { currentTurn, nextTurns } = nextState;\n\n    graphics.fillStyle(0xffffff, 1); // color: white\n    nextState.indicators = currentTurn.map(createPathPoint);\n\n    graphics.fillStyle(0xff0000, 1); // color: red\n    nextState.nextIndicators = nextTurns.map(createPathPoint);\n\n    state = nextState;\n  };\n\n  return { move, clear };\n};\n","export default class Army {\n  constructor(scene, x, y, type) {\n    this.scene = scene;\n    this.movementPoints = 4;\n    this.body = scene.physics.add\n      .sprite(x, y, type)\n      .setDisplaySize(64, 64)\n      .setDisplayOrigin(-16, -10)\n      .setInteractive()\n      .on(\"pointerdown\", () => (scene.target = this));\n\n    this.onCastle = false;\n\n    this.body.on(\"overlapstart\", function() {\n      this.body.debugBodyColor = 0xff3300;\n      this.onCastle = true;\n      alert(\"You're on a castle\");\n    });\n\n    this.body.on(\"overlapend\", function() {\n      this.body.debugBodyColor = 0x00ff33;\n      this.onCastle = false;\n    });\n\n    this.scene.triggers.forEach(trigger => {\n      this.scene.physics.add.overlap(this.body, trigger);\n    });\n  }\n\n  spendMovement = amount => (this.movementPoints -= amount);\n\n  resetMovement = () => (this.movementPoints = 4);\n\n  update = () => {\n    const {\n      body: { body }\n    } = this;\n\n    if (body.embedded) body.touching.none = false;\n\n    const touching = !body.touching.none;\n    const wasTouching = !body.wasTouching.none;\n\n    if (touching && !wasTouching) this.body.emit(\"overlapstart\");\n    else if (!touching && wasTouching) this.body.emit(\"overlapend\");\n  };\n}\n","import Army from \"./Army\";\n\nconst INITIAL_STATE = {\n  turn: 1,\n  name: \"\",\n  money: 0,\n  armies: [],\n  castles: []\n};\n\nconst player = (scene, id) => {\n  let state = {\n    ...INITIAL_STATE,\n    name: `Player ${id}`\n  };\n\n  const endTurn = () => {\n    state.armies.forEach(army => army.resetMovement());\n\n    state = {\n      ...state,\n      turn: state.turn + 1\n    };\n  };\n\n  const addArmy = (x, y, type) => {\n    const newArmy = new Army(scene, x, y, type);\n    state = {\n      ...state,\n      armies: [...state.armies, newArmy]\n    };\n    return newArmy;\n  };\n\n  const name = () => state.name;\n  const turn = () => state.turn;\n  const update = () => state.armies.forEach(army => army.update());\n\n  return {\n    state,\n    name,\n    turn,\n    update,\n    endTurn,\n    addArmy\n  };\n};\n\nexport default player;\n","import { Math as PhaserMath, Scene as PhaserScene } from \"phaser\";\n\nimport generator from \"./TerrainGen\";\nimport Scene from \"./Scene\";\nimport Map from \"./Map\";\nimport Movement from \"./Movement\";\nimport Player from \"./Player\";\n\nconst MAP_WIDTH = 100;\nconst MAP_HEIGHT = 100;\nconst TILE_WIDTH = 128;\nconst TILE_HEIGHT = 128;\n// const SEED = 0.8444330836642344;\n\nconst worldToTile = (x, y) => ({\n  x: Math.floor(x / TILE_WIDTH),\n  y: Math.floor(y / TILE_HEIGHT)\n});\n\nconst tileToWorld = (x, y) => ({\n  x: Math.floor(x * TILE_WIDTH),\n  y: Math.floor(y * TILE_HEIGHT)\n});\n\nexport default class GameScene extends Scene {\n  constructor() {\n    super(\"GameScene\");\n    this.players = [];\n  }\n\n  addPlayer() {\n    const playerId = this.players.length;\n    const newPlayer = Player(this, playerId);\n    this.players.push(newPlayer);\n    return newPlayer;\n  }\n\n  preload() {\n    this.load.setBaseURL(`${process.env.PUBLIC_URL}`);\n    this.load.image(\"tileset\", \"tilesets/tileset-extruded.png\");\n    this.load.image(\"warrior\", \"warrior.png\");\n    // this.load.tilemapTiledJSON(\"map\", \"/tilemaps/copycat.json\");\n  }\n\n  create() {\n    const world = generator(MAP_WIDTH, MAP_HEIGHT);\n    const { map, finder, costMatrix, spawnPoint, terrainLayer } = Map(\n      this,\n      world,\n      MAP_WIDTH,\n      MAP_HEIGHT\n    );\n    this.finder = finder;\n    this.terrainLayer = terrainLayer;\n    const { tileWidth, tileHeight } = map;\n\n    const spawn = tileToWorld(spawnPoint.x - 2, spawnPoint.y + 2);\n\n    const player = this.addPlayer();\n    this.target = player.addArmy(spawn.x, spawn.y, \"warrior\");\n\n    this.setupCamera(terrainLayer.width, terrainLayer.height);\n    this.camera.centerOn(spawn.x, spawn.y);\n\n    this.movement = Movement(this, costMatrix, tileWidth, tileHeight);\n\n    this.createMapControls();\n    this.input.on(\"pointerdown\", this.onPointerDown);\n\n    this.scene.run(\"UI\");\n  }\n\n  onPointerDown = ({ worldX, worldY }) => {\n    if (!this.target) return;\n\n    const to = worldToTile(worldX, worldY);\n    const from = worldToTile(this.target.body.x, this.target.body.y);\n    const onPathCalculated = this.movement.move(this.target);\n\n    try {\n      this.finder.findPath(from.x, from.y, to.x, to.y, onPathCalculated);\n      this.finder.calculate();\n    } catch (error) {\n      console.error(\"Ups! Out of scope :S\");\n    }\n  };\n\n  update(time, delta) {\n    this.controls.update(delta);\n    this.camera.setZoom(PhaserMath.Clamp(this.camera.zoom, 0.08, 1));\n    this.players.forEach(player => player.update());\n  }\n}\n","import EasyStar from \"easystarjs\";\nimport { includes } from \"lodash\";\n\nimport {\n  TERRAIN_ID,\n  FOREST_ID,\n  CASTLE_ID,\n  MOUNTAIN_ID,\n  WATER_ID\n} from \"./TerrainGen\";\n\nconst setTileCost = (costMatrix, finder) => (tile, x, y, cost) => {\n  finder.setTileCost(tile, cost);\n  costMatrix[y] = costMatrix[y] || [];\n  costMatrix[y][x] = cost;\n};\n\nexport default (scene, world, width, height) => {\n  const map = scene.make.tilemap({ tileWidth: 128, tileHeight: 128 });\n  const { tileWidth, tileHeight } = map;\n  const tileset = map.addTilesetImage(\n    \"tileset\",\n    \"tileset\",\n    tileWidth,\n    tileHeight,\n    1,\n    2\n  );\n\n  let terrainLayer = map.createBlankDynamicLayer(\n    \"terrain\",\n    tileset,\n    0,\n    0,\n    width,\n    height\n  );\n\n  let objectLayer = map.createBlankDynamicLayer(\n    \"object\",\n    tileset,\n    0,\n    0,\n    width,\n    height\n  );\n\n  let spawnPoint;\n\n  const finder = new EasyStar.js();\n  finder.setGrid(world);\n  finder.setAcceptableTiles([...TERRAIN_ID, ...MOUNTAIN_ID, ...FOREST_ID]);\n  finder.enableDiagonals();\n  // finder.enableCornerCutting();\n\n  const costMatrix = [];\n  const setCost = setTileCost(costMatrix, finder);\n  scene.triggers = [];\n\n  world.forEach((row, y) =>\n    row.forEach((tile, x) => {\n      if (!spawnPoint && includes(CASTLE_ID, tile)) spawnPoint = { x, y };\n\n      if (includes(CASTLE_ID, tile)) {\n        terrainLayer.putTileAt(TERRAIN_ID[0], x, y);\n        objectLayer.putTileAt(tile, x, y);\n        if (tile === CASTLE_ID[0]) {\n          const trigger = scene.add\n            .zone(x * tileWidth + tileWidth, y * tileWidth + tileHeight)\n            .setSize(tileWidth * 2 + 64, tileHeight * 2 + 64);\n          scene.physics.world.enable(trigger);\n          trigger.body.setAllowGravity(false);\n          trigger.body.moves = false;\n          scene.triggers.push(trigger);\n        }\n      } else terrainLayer.putTileAt(tile, x, y);\n\n      if (includes(TERRAIN_ID, tile)) setCost(tile, x, y, 1);\n      if (includes(FOREST_ID, tile)) setCost(tile, x, y, 2);\n      if (includes(MOUNTAIN_ID, tile)) setCost(tile, x, y, 3);\n    })\n  );\n\n  terrainLayer = map.convertLayerToStatic(terrainLayer);\n  objectLayer = map.convertLayerToStatic(objectLayer);\n\n  objectLayer.setTileIndexCallback(24, () => console.log(\"here 24\"), scene);\n  objectLayer.setTileIndexCallback(25, () => console.log(\"here 25\"), scene);\n\n  scene.objectLayer = objectLayer;\n\n  return {\n    map,\n    finder,\n    costMatrix,\n    spawnPoint,\n    terrainLayer\n  };\n};\n","import Phaser, { Game } from \"phaser\";\n\n// import game from \"./Game\";\nimport UI from \"./UI\";\nimport GameScene from \"./GameScene\";\n\nconst physics = {\n  default: \"arcade\",\n  arcade: {\n    debug: true,\n    gravity: { y: 0 }\n  }\n};\n\nconst config = {\n  physics,\n  type: Phaser.AUTO,\n  width: 800,\n  height: 600,\n  parent: \"App\",\n  pixelArt: true,\n  scene: [GameScene, UI]\n};\n\nnew Game(config);\n","import React from \"react\";\n\nimport \"./App.css\";\n\n// import \"./StaticTileMap\";\nimport \"./Game\";\n\nfunction App() {\n  return <div className=\"App\" id=\"App\"></div>;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}